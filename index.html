<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Legacy Compass Mobile</title>
    
    <!-- Tailwind CSS with safe area config -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    spacing: {
                        'safe': 'env(safe-area-inset-bottom)',
                        'safe-top': 'env(safe-area-inset-top)',
                    }
                }
            }
        }
    </script>
    
    <!-- Mapbox GL JS -->
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css' rel='stylesheet' />
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js'></script>
    
    <!-- Mapbox Marker Clustering -->
    <script src="https://unpkg.com/supercluster@8.0.1/dist/supercluster.min.js"></script>
    
    <!-- Supabase -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="js/supabase-client.js"></script>
    
    <!-- Alpine.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.0/dist/cdn.min.js"></script>
    
    <script>
        // Mapbox marker creation function (works perfectly with Alpine!)
        window.createPropertyMarkers = function(map, properties, markerArray) {
            // Clear existing markers
            if (markerArray && markerArray.length > 0) {
                markerArray.forEach(m => {
                    try { m.remove(); } catch(e) {}
                });
                markerArray.length = 0;
            }
            
            let created = 0;
            const maxMarkers = Math.min(properties.length, 500); // Show more markers
            
            for (let i = 0; i < maxMarkers; i++) {
                const prop = properties[i];
                let lng = parseFloat(prop.lng);
                let lat = parseFloat(prop.lat);
                
                // If no coordinates, generate them in Hayward area
                if (!lng || !lat || isNaN(lng) || isNaN(lat)) {
                    const row = Math.floor(i / 50);
                    const col = i % 50;
                    lat = 37.6688 + (row * 0.003) - 0.05; // Spread around Hayward
                    lng = -122.0808 + (col * 0.003) - 0.05;
                }
                
                if (lng && lat && !isNaN(lng) && !isNaN(lat)) {
                    try {
                        // Create custom HTML element for marker
                        const el = document.createElement('div');
                        el.className = 'marker';
                        el.style.width = '25px';
                        el.style.height = '25px';
                        el.style.borderRadius = '50%';
                        el.style.border = '2px solid white';
                        el.style.cursor = 'pointer';
                        el.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
                        
                        // Color based on property type
                        if (prop.absentee) {
                            el.style.backgroundColor = '#ff6b00'; // Orange
                        } else if (prop.equity > 50) {
                            el.style.backgroundColor = '#dc2626'; // Red
                        } else {
                            el.style.backgroundColor = '#3b82f6'; // Blue
                        }
                        
                        // Create Mapbox marker (no proxy issues!)
                        const marker = new mapboxgl.Marker(el)
                            .setLngLat([lng, lat])
                            .setPopup(new mapboxgl.Popup({ offset: 25 })
                                .setHTML(`
                                    <div style="padding: 8px;">
                                        <b>${prop.address || 'Property'}</b><br>
                                        Owner: ${prop.owner || 'Unknown'}<br>
                                        Equity: ${prop.equity || 0}%
                                        ${prop.absentee ? '<br><span style="color: #ff6b00;">ABSENTEE</span>' : ''}
                                    </div>
                                `))
                            .addTo(map);
                        
                        markerArray.push(marker);
                        created++;
                    } catch (e) {
                        console.error(`Marker ${i} failed:`, e);
                    }
                }
            }
            
            console.log(`✅ Created ${created} Mapbox markers successfully!`);
            return created;
        };
    </script>
    
    <style>
        /* Force full height on mobile with safe areas */
        html, body {
            height: 100vh;
            height: 100dvh;
            height: -webkit-fill-available;
            overflow: hidden;
            background: #000;
            padding: 0;
            margin: 0;
        }
        
        /* Container fills viewport properly */
        .app-container {
            height: 100vh;
            height: 100dvh;
            height: -webkit-fill-available;
        }
        
        /* Custom scrollbar for properties */
        .property-list::-webkit-scrollbar {
            width: 4px;
        }
        .property-list::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        .property-list::-webkit-scrollbar-thumb {
            background: #ff9500;
            border-radius: 2px;
        }
        
        /* Map controls */
        .mapboxgl-ctrl-top-right {
            top: 10px !important;
            right: 10px !important;
        }
        
        /* Pulse animation for focused markers */
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(251, 146, 60, 0.7);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 0 10px rgba(251, 146, 60, 0);
                transform: scale(1.1);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(251, 146, 60, 0);
                transform: scale(1);
        }
        
        .pulse-animation {
            animation: pulse 1s infinite;
        }
        
        /* Marker animations and legend styles */
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 30px rgba(255,0,0,0.9); }
            50% { transform: scale(1.3); box-shadow: 0 0 50px rgba(255,0,0,1); }
            100% { transform: scale(1); box-shadow: 0 0 30px rgba(255,0,0,0.9); }
        }
        
        .marker-legend {
            display: block !important;
        }
        
        .marker-legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .marker-legend-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-black text-white">
    <div x-data="legacyApp()" x-init="init()" class="app-container flex flex-col">
        
        <!-- Header - Always visible but minimal when Details open -->
        <div class="bg-gray-900 border-b border-orange-500 px-2 py-1 flex-shrink-0 fixed top-0 left-0 right-0 z-[60]">
            <div class="flex justify-between items-center" :class="selectedProperty ? '' : 'mb-1'">
                <div class="flex items-center gap-2">
                    <div class="w-2 h-2 bg-orange-500 rounded-full"></div>
                    <span class="text-orange-500 font-bold text-sm">Legacy Compass</span>
                </div>
                <div class="flex items-center gap-2">
                    <span class="text-gray-400 text-xs" x-text="currentUser ? currentUser.email : 'Demo Mode'"></span>
                    <button @click="logout()" class="text-xs bg-gray-700 hover:bg-gray-600 text-white px-2 py-1 rounded">
                        Logout
                    </button>
                </div>
            </div>
            <div x-show="!selectedProperty" class="grid grid-cols-4 gap-1 text-center">
                <div>
                    <div class="text-orange-500 font-bold text-base" x-text="displayedCount + '/' + stats.total">0</div>
                    <div class="text-yellow-500 text-[8px] uppercase">Showing</div>
                </div>
                <div>
                    <div class="text-yellow-500 font-bold text-base" x-text="stats.absentee">0%</div>
                    <div class="text-yellow-500 text-[8px] uppercase">Absentee</div>
                </div>
                <div>
                    <div class="text-green-500 font-bold text-base" x-text="stats.avgEquity">0%</div>
                    <div class="text-yellow-500 text-[8px] uppercase">Equity</div>
                </div>
                <div>
                    <div class="text-blue-500 font-bold text-base" x-text="allTags.size">0</div>
                    <div class="text-yellow-500 text-[8px] uppercase">Tags</div>
                </div>
            </div>
        </div>
        
        <!-- Main Content - Full Width Map -->
        <div class="flex-1 relative overflow-hidden" style="margin-bottom: calc(35vh + 60px); padding-top: 80px;">
            
            <!-- Map Section - Full Width -->
            <div class="flex flex-col h-full">
                <!-- Map Controls Section -->
                <div class="bg-gray-900 p-2 flex-shrink-0 relative z-10">
                    <!-- Map Search Bar -->
                    <div class="flex gap-2 mb-1">
                        <input type="text" 
                               x-model="searchQuery"
                               @keyup.enter="searchAddress()"
                               placeholder="🔍 Search any address or location..."
                               class="flex-1 bg-gray-800 text-white px-3 py-2 rounded text-sm border border-gray-700 focus:border-orange-500 focus:outline-none">
                        <button @click="searchAddress()" 
                                class="bg-orange-500 hover:bg-orange-400 text-black px-4 py-2 rounded font-bold text-sm">
                            Go
                        </button>
                    </div>
                    
                    <!-- Map Style Controls -->
                    <div class="flex gap-1">
                        <button class="flex-1 py-1 text-[10px] rounded"
                                :class="mapStyle === 'day' ? 'bg-blue-500 text-white' : 'bg-gray-800 text-gray-400'"
                                @click="setMapStyle('day')">☀️</button>
                        <button class="flex-1 py-1 text-[10px] rounded"
                                :class="mapStyle === 'dusk' ? 'bg-purple-500 text-white' : 'bg-gray-800 text-gray-400'"
                                @click="setMapStyle('dusk')">🌅</button>
                        <button class="flex-1 py-1 text-[10px] rounded"
                                :class="mapStyle === 'night' ? 'bg-indigo-600 text-white' : 'bg-gray-800 text-gray-400'"
                                @click="setMapStyle('night')">🌙</button>
                        <button class="flex-1 py-1 text-[10px] rounded"
                                :class="mapStyle === 'satellite' ? 'bg-green-500 text-white' : 'bg-gray-800 text-gray-400'"
                                @click="setMapStyle('satellite')">🛰️</button>
                        <button class="flex-1 py-1 text-[10px] rounded"
                                :class="is3D ? 'bg-orange-500 text-white' : 'bg-gray-800 text-gray-400'"
                                @click="toggle3D()">🏢</button>
                    </div>
                </div>
                <!-- Map Container - Full Width -->
                <div id="map" class="flex-1"></div>
            </div>
            
            <!-- Fixed Bottom Properties Panel (expands for details) -->
            <div class="fixed bottom-0 left-0 right-0 bg-gray-900 border-t-2 border-orange-500 z-40 transition-all duration-300" 
                 :style="`height: ${selectedProperty ? '70vh' : '35vh'}; margin-bottom: 60px;`">
                
                <!-- Dynamic Header (changes based on view) -->
                <div class="bg-gray-800 p-2 border-b border-gray-700" x-show="!selectedProperty">
                    <div class="flex items-center gap-2">
                        <!-- Property Type Filters -->
                        <button class="py-1 px-2 text-[10px] rounded font-bold"
                                :class="propertyFilter === 'all' ? 'bg-orange-500 text-black' : 'bg-gray-700 text-gray-400'"
                                @click="filterByType('all')">
                            ALL (<span x-text="stats.total || 0"></span>)
                        </button>
                        <button class="py-1 px-2 text-[10px] rounded font-bold"
                                :class="propertyFilter === 'sfr' ? 'bg-orange-500 text-black' : 'bg-gray-700 text-gray-400'"
                                @click="filterByType('sfr')">
                            SFR (<span x-text="typeCount.sfr || 0"></span>)
                        </button>
                        <button class="py-1 px-2 text-[10px] rounded font-bold"
                                :class="propertyFilter === 'condo' ? 'bg-orange-500 text-black' : 'bg-gray-700 text-gray-400'"
                                @click="filterByType('condo')">
                            CONDO (<span x-text="typeCount.condo || 0"></span>)
                        </button>
                        <button class="py-1 px-2 text-[10px] rounded font-bold"
                                :class="propertyFilter === 'commercial' ? 'bg-orange-500 text-black' : 'bg-gray-700 text-gray-400'"
                                @click="filterByType('commercial')">
                            COMM (<span x-text="typeCount.commercial || 0"></span>)
                        </button>
                        <button class="py-1 px-2 text-[10px] rounded font-bold"
                                :class="propertyFilter === 'multi' ? 'bg-orange-500 text-black' : 'bg-gray-700 text-gray-400'"
                                @click="filterByType('multi')">
                            MULTI (<span x-text="typeCount.multi || 0"></span>)
                        </button>
                        <!-- Property Search -->
                        <input type="text" 
                               x-model="propertySearch" 
                               @input="filterProperties()"
                               placeholder="Search or #tag..." 
                               class="flex-1 px-2 py-1 bg-gray-900 text-white rounded text-xs border border-gray-700 focus:border-orange-500">
                    </div>
                </div>
                
                <!-- Property Details Header (shows when property selected) -->
                <div class="bg-gray-800 p-3 border-b border-gray-700" x-show="selectedProperty">
                    <div class="flex items-center justify-between">
                        <div>
                            <h3 class="text-white font-bold" x-text="selectedProperty?.address"></h3>
                            <p class="text-gray-400 text-sm" x-text="selectedProperty?.owner"></p>
                        </div>
                        <button @click="selectedProperty = null" 
                                class="bg-gray-700 hover:bg-gray-600 text-white px-3 py-1 rounded text-sm">
                            ← Back
                        </button>
                    </div>
                </div>
                
                <!-- Property List (shows when no property selected) -->
                <div x-show="!selectedProperty" class="flex-1 overflow-y-auto property-list p-2" style="max-height: 300px; overflow-y: auto;">
                    <template x-if="loading">
                            <div class="text-center py-4 text-yellow-500 text-xs">
                                Loading properties...
                            </div>
                        </template>
                        
                        <template x-if="!loading && properties.length === 0">
                            <div class="text-center py-8">
                                <svg class="w-16 h-16 mx-auto mb-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                                </svg>
                                <p class="text-gray-400 font-semibold mb-2">No Properties Loaded</p>
                                <p class="text-gray-500 text-sm mb-4">Upload Jeff & Anna's CSV file</p>
                                <button @click="uploadCSV()" 
                                        class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded text-sm">
                                    📁 Upload CSV
                                </button>
                            </div>
                        </template>
                        
                        <template x-if="!loading && filteredProperties.length === 0 && properties.length > 0">
                            <div class="text-center py-4 text-gray-500 text-xs">
                                No properties match current filters
                            </div>
                        </template>
                        
                        <template x-for="property in paginatedProperties" :key="property.id">
                        <div class="bg-gray-800 p-2 mb-1 rounded hover:bg-gray-700 transition-colors border border-gray-700 cursor-pointer"
                             @click="showPropertyDetails(property)">
                            
                            <!-- Header - Address and Owner -->
                            <div class="flex justify-between items-start mb-1">
                                <div class="flex-1">
                                    <div class="text-white text-[11px] font-bold truncate" x-text="property.address"></div>
                                    <div class="text-gray-400 text-[10px] truncate" x-text="property.owner"></div>
                                </div>
                                <div class="text-right">
                                    <div class="text-cyan-400 font-bold text-sm" x-text="property.equity + '%'"></div>
                                    <div class="text-gray-500 text-[8px]">Equity</div>
                                </div>
                            </div>
                            
                            <!-- Tags Row -->
                            <div class="flex flex-wrap gap-1 mb-1">
                                <!-- Owner/Absentee Badge -->
                                <span x-show="property.absentee" class="px-1.5 py-0.5 bg-orange-900/50 text-orange-400 text-[9px] rounded border border-orange-400">Absentee</span>
                                <span x-show="!property.absentee" class="px-1.5 py-0.5 bg-green-900/50 text-green-400 text-[9px] rounded border border-green-400">Owner</span>
                                <!-- High Equity Badge -->
                                <span x-show="property.equity > 70" class="px-1.5 py-0.5 bg-red-900/50 text-red-400 text-[9px] rounded border border-red-400">Hot</span>
                                <span x-show="!property.tags || !property.tags.includes('contacted')" class="px-1.5 py-0.5 bg-blue-900/50 text-blue-400 text-[9px] rounded border border-blue-400">New</span>
                                <!-- Custom Tags -->
                                <template x-for="tag in (property.tags || [])" :key="tag">
                                    <span class="px-1.5 py-0.5 bg-gray-700 text-gray-300 text-[9px] rounded" x-text="tag"></span>
                                </template>
                            </div>
                            
                            <!-- Action Buttons Row -->
                            <div class="flex gap-1">
                                <button class="flex-1 px-2 py-1 bg-cyan-600 hover:bg-cyan-500 text-white text-[9px] rounded transition-colors"
                                        @click.stop="focusProperty(property)">
                                    🎯 Focus
                                </button>
                                <button @click.stop="showPropertyDetails(property)" class="flex-1 px-2 py-1 bg-gray-700 hover:bg-gray-600 text-white text-[9px] rounded transition-colors">
                                    ℹ️ Details
                                </button>
                                <button class="px-2 py-1 bg-gray-700 hover:bg-gray-600 text-white text-[9px] rounded transition-colors"
                                        @click.stop="startVoiceNote(property)">
                                    🎤
                                </button>
                            </div>
                        </div>
                    </template>
                </div>
                
                <!-- Property Details View (shows when property selected) -->
                <div x-show="selectedProperty" class="fixed inset-0 z-50 flex flex-col" style="background-color: #0a0a0a; padding-top: 45px; padding-bottom: 70px;">
                    <!-- Property Header with Back -->
                    <div class="bg-gray-800 border-b border-gray-700 p-3 sticky top-0 z-10">
                        <div class="flex justify-between items-center">
                            <div>
                                <h2 class="text-white font-bold text-sm" x-text="selectedProperty?.address"></h2>
                                <p class="text-gray-400 text-xs" x-text="selectedProperty?.owner"></p>
                            </div>
                            <button @click="selectedProperty = null; detailsTab = 'overview'" 
                                    class="bg-gray-700 hover:bg-gray-600 text-white px-3 py-1 rounded text-xs">
                                ← Back
                            </button>
                        </div>
                    </div>
                    
                    <!-- Tabs Navigation -->
                    <div class="bg-gray-900 border-b border-gray-700 flex sticky top-12 z-10">
                        <button @click="detailsTab = 'overview'" 
                                :class="detailsTab === 'overview' ? 'bg-orange-500 text-black' : 'bg-gray-800 text-gray-400'"
                                class="flex-1 py-2 px-3 text-xs font-bold transition-colors">
                            📊 Overview
                        </button>
                        <button @click="detailsTab = 'ghost'" 
                                :class="detailsTab === 'ghost' ? 'bg-orange-500 text-black' : 'bg-gray-800 text-gray-400'"
                                class="flex-1 py-2 px-3 text-xs font-bold transition-colors">
                            🤖 Ghost AI
                        </button>
                    </div>

                    <!-- Tab Content - No scroll, everything in view -->
                    <div class="flex-1 flex flex-col p-2" style="overflow: hidden; height: 100%;">
                        <!-- Overview Tab -->
                        <div x-show="detailsTab === 'overview'" x-transition class="flex flex-col" style="height: 100%;">
                            <!-- Mini Map - Much Larger -->
                            <div class="bg-gray-900 rounded mb-1 relative overflow-hidden" style="height: calc(100vh - 480px); min-height: 200px;">
                                <div id="mini-map" class="w-full h-full"></div>
                                <div class="absolute bottom-2 left-2 bg-black bg-opacity-70 text-white text-[10px] px-2 py-1 rounded">
                                    📍 <span x-text="selectedProperty?.address"></span>
                                </div>
                            </div>

                            <!-- Quick Actions Bar - Smaller -->
                            <div class="grid grid-cols-5 gap-1 mb-1">
                                <button @click="callOwner(selectedProperty)" 
                                        class="bg-gray-800 hover:bg-gray-700 text-cyan-400 py-2 rounded flex flex-col items-center text-xs">
                                    <span>📞</span>
                                    <span class="text-[9px]">Call</span>
                                </button>
                                <button class="bg-gray-800 hover:bg-gray-700 text-gray-400 py-2 rounded flex flex-col items-center text-xs">
                                    <span>💬</span>
                                    <span class="text-[9px]">Text</span>
                                </button>
                                <button class="bg-gray-800 hover:bg-gray-700 text-gray-400 py-2 rounded flex flex-col items-center text-xs">
                                    <span>✉️</span>
                                    <span class="text-[9px]">Email</span>
                                </button>
                                <button @click="routeToProperty(selectedProperty)" 
                                        class="bg-gray-800 hover:bg-gray-700 text-orange-400 py-2 rounded flex flex-col items-center text-xs">
                                    <span>🚗</span>
                                    <span class="text-[9px]">Route</span>
                                </button>
                                <button class="bg-gray-800 hover:bg-gray-700 text-yellow-400 py-2 rounded flex flex-col items-center text-xs">
                                    <span>📮</span>
                                    <span class="text-[9px]">Mailer</span>
                                </button>
                            </div>

                            <!-- Key Metrics - Compact -->
                            <div class="grid grid-cols-3 gap-1 mb-1">
                                <div class="bg-gray-900 p-1 rounded text-center">
                                    <div class="text-cyan-400 text-lg font-bold" x-text="(selectedProperty?.equity || 0) + '%'"></div>
                                    <div class="text-gray-600 text-[9px] uppercase">Equity</div>
                                </div>
                                <div class="bg-gray-900 p-1 rounded text-center">
                                    <div class="text-green-400 text-lg font-bold">$<span x-text="Math.floor((parseInt(selectedProperty?.['Purchase Price'] || 0))/1000) + 'k'"></span></div>
                                    <div class="text-gray-600 text-[9px] uppercase">Purchase</div>
                                </div>
                                <div class="bg-gray-900 p-1 rounded text-center">
                                    <div class="text-orange-400 text-lg font-bold" x-text="selectedProperty?.['Year Built'] || 'N/A'"></div>
                                    <div class="text-gray-600 text-[9px] uppercase">Built</div>
                                </div>
                            </div>

                            <!-- Property Details Grid - Compact -->
                            <div class="grid grid-cols-2 gap-1">
                                <!-- Owner Information - Compact -->
                                <div class="bg-gray-900 p-2 rounded">
                                    <h4 class="text-orange-500 text-xs font-bold mb-1 uppercase tracking-wider">Owner Details</h4>
                                    <div class="space-y-1 text-xs">
                                        <div class="flex justify-between py-0">
                                            <span class="text-gray-500 font-medium">Name:</span>
                                            <span class="text-white font-semibold text-sm" x-text="selectedProperty?.owner || 'N/A'"></span>
                                        </div>
                                        <div class="flex justify-between py-0">
                                            <span class="text-gray-500 font-medium">Status:</span>
                                            <span :class="selectedProperty?.absentee ? 'text-orange-400' : 'text-green-400'" 
                                                  class="font-bold text-sm"
                                                  x-text="selectedProperty?.absentee ? 'Absentee' : 'Owner Occupied'"></span>
                                        </div>
                                        <div class="flex justify-between py-0">
                                            <span class="text-gray-500 font-medium">Mailing:</span>
                                            <span class="text-white text-xs" x-text="selectedProperty?.['Mailing City'] || 'N/A'"></span>
                                        </div>
                                        <div class="flex justify-between py-0">
                                            <span class="text-gray-500 font-medium">Phone:</span>
                                            <span class="text-white text-xs" x-text="selectedProperty?.phone || 'N/A'"></span>
                                        </div>
                                    </div>
                                </div>

                                <!-- Property Specs - Compact -->
                                <div class="bg-gray-900 p-2 rounded">
                                    <h4 class="text-orange-500 text-xs font-bold mb-1 uppercase tracking-wider">Property Specs</h4>
                                    <div class="space-y-1 text-xs">
                                        <div class="flex justify-between py-0">
                                            <span class="text-gray-500 font-medium">Size:</span>
                                            <span class="text-white font-semibold text-sm" x-text="(selectedProperty?.['Building Size'] || 0) + ' sqft'"></span>
                                        </div>
                                        <div class="flex justify-between py-0">
                                            <span class="text-gray-500 font-medium">Rooms:</span>
                                            <span class="text-white font-bold text-sm" x-text="`${selectedProperty?.Bedrooms || 0}bd / ${selectedProperty?.Baths || 0}ba`"></span>
                                        </div>
                                        <div class="flex justify-between py-0">
                                            <span class="text-gray-500 font-medium">Lot:</span>
                                            <span class="text-white text-xs" x-text="(selectedProperty?.['Lot Size Total Acreage'] || 0) + ' acres'"></span>
                                        </div>
                                        <div class="flex justify-between py-0">
                                            <span class="text-gray-500 font-medium">Year:</span>
                                            <span class="text-white text-xs" x-text="selectedProperty?.['Year Built'] || 'N/A'"></span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Notes Section - Smaller to give more space to map -->
                            <div class="bg-gray-900 p-2 rounded mt-1 flex flex-col" style="height: 140px;">
                                <h4 class="text-orange-500 text-xs font-bold mb-1 uppercase tracking-wider">Notes & Activity</h4>
                                
                                <!-- Activity History - Fill available space in smaller container -->
                                <div class="bg-gray-800 rounded p-2 mb-2 flex-1" style="overflow-y: auto; min-height: 0;">
                                    <div class="text-gray-500 text-[10px] uppercase mb-1">Activity History</div>
                                    <div class="space-y-1">
                                        <template x-for="note in (selectedProperty?.notes || [])" :key="note.id">
                                            <div class="bg-gray-900 p-2 rounded text-[10px] group hover:bg-gray-800">
                                                <div class="flex justify-between items-start">
                                                    <div class="flex-1">
                                                        <div class="text-gray-400" x-text="note.timestamp"></div>
                                                        <div class="text-white" x-text="note.isVoice ? '🎤 ' + note.content : note.content"></div>
                                                    </div>
                                                    <div class="opacity-0 group-hover:opacity-100 flex gap-1 ml-2">
                                                        <button @click="editNote(note)" 
                                                                class="text-blue-400 hover:text-blue-300 text-[9px]">
                                                            ✏️
                                                        </button>
                                                        <button @click="deleteNote(note.id)" 
                                                                class="text-red-400 hover:text-red-300 text-[9px]">
                                                            🗑️
                                                        </button>
                                                    </div>
                                                </div>
                                            </div>
                                        </template>
                                        <div x-show="!selectedProperty?.notes || selectedProperty.notes.length === 0" 
                                             class="text-gray-600 text-xs text-center py-2">
                                            No activity recorded yet
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Note Input - Fixed at bottom -->
                                <div class="flex gap-1 mt-auto">
                                    <input type="text" 
                                           class="flex-1 bg-gray-800 text-white p-2 rounded text-sm border border-gray-700 focus:border-orange-500 focus:outline-none" 
                                           placeholder="Add a quick note..."
                                           x-model="newPropertyNote"
                                           @keyup.enter="addPropertyNote()">
                                    <button @click="startVoiceRecording()" 
                                            class="bg-red-700 hover:bg-red-600 text-white px-3 py-2 rounded text-sm font-medium"
                                            :class="isRecording ? 'animate-pulse bg-red-500' : ''">
                                        <span x-text="isRecording ? '⏹️' : '🎤'"></span>
                                    </button>
                                    <button @click="addPropertyNote()" 
                                            class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded text-sm font-bold">
                                        Add Note
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Ghost AI Tab -->
                        <div x-show="detailsTab === 'voice'" x-transition>
                            <div class="bg-gray-800 rounded-lg p-4">
                                <div class="mb-4">
                                    <button @click="startVoiceRecording()" 
                                            class="w-full bg-gradient-to-r from-red-600 to-red-500 hover:from-red-500 hover:to-red-400 text-white py-4 rounded-lg flex items-center justify-center">
                                        <span class="text-3xl mr-3">🎤</span>
                                        <span class="font-bold">Start Voice Note</span>
                                    </button>
                                </div>

                                <!-- Voice Notes List -->
                                <div class="space-y-2">
                                    <div class="text-gray-400 text-xs uppercase font-bold mb-2">Previous Notes</div>
                                    <template x-for="note in (selectedProperty?.voiceNotes || [])" :key="note.id">
                                        <div class="bg-gray-900 p-3 rounded flex items-center justify-between">
                                            <div class="flex-1">
                                                <div class="text-white text-xs" x-text="note.transcript"></div>
                                                <div class="text-gray-500 text-[10px] mt-1" x-text="note.timestamp"></div>
                                            </div>
                                            <button class="text-cyan-400 hover:text-cyan-300 ml-3">
                                                ▶️
                                            </button>
                                        </div>
                                    </template>
                                    <div x-show="!selectedProperty?.voiceNotes || selectedProperty.voiceNotes.length === 0" 
                                         class="text-gray-500 text-center py-8 text-xs">
                                        No voice notes yet. Tap the button above to record your first note.
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Ghost AI Tab -->
                        <div x-show="detailsTab === 'ghost'" x-transition>
                            <div class="space-y-3">
                                <!-- AI Analysis -->
                                <div class="bg-gradient-to-r from-purple-900 to-indigo-900 p-4 rounded-lg">
                                    <h4 class="text-white text-xs font-bold mb-3 uppercase">🤖 Ghost AI Analysis</h4>
                                    <button @click="analyzeWithGhost(selectedProperty)" 
                                            class="w-full bg-purple-600 hover:bg-purple-500 text-white py-2 rounded text-sm font-bold">
                                        Analyze Property
                                    </button>
                                </div>

                                <!-- AI Suggestions -->
                                <div class="bg-gray-800 p-3 rounded">
                                    <h4 class="text-orange-500 text-xs font-bold mb-2 uppercase">AI Suggestions</h4>
                                    <div class="space-y-2 text-xs">
                                        <div class="bg-gray-900 p-2 rounded">
                                            <span class="text-cyan-400">💡</span>
                                            <span class="text-gray-300 ml-2">High equity property - prime for cash offer</span>
                                        </div>
                                        <div class="bg-gray-900 p-2 rounded">
                                            <span class="text-green-400">📈</span>
                                            <span class="text-gray-300 ml-2">Market value increased 15% last year</span>
                                        </div>
                                        <div class="bg-gray-900 p-2 rounded">
                                            <span class="text-yellow-400">⏰</span>
                                            <span class="text-gray-300 ml-2">Best contact time: Weekdays 5-7 PM</span>
                                        </div>
                                    </div>
                                </div>

                                <!-- Generate Actions -->
                                <div class="grid grid-cols-2 gap-2">
                                    <button class="bg-gray-700 hover:bg-gray-600 text-white py-2 rounded text-xs font-bold">
                                        📧 Generate Email
                                    </button>
                                    <button class="bg-gray-700 hover:bg-gray-600 text-white py-2 rounded text-xs font-bold">
                                        💬 Generate Text
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Activity Tab -->
                        <div x-show="detailsTab === 'activity'" x-transition>
                            <div class="bg-gray-800 rounded-lg p-3">
                                <div class="mb-3">
                                    <textarea 
                                        class="w-full bg-gray-900 text-white p-3 rounded text-xs" 
                                        rows="4" 
                                        placeholder="Add a note about this property..."
                                        @input="savePropertyNote(selectedProperty, $event.target.value)"
                                        :value="getPropertyNote(selectedProperty)">
                                    </textarea>
                                    <button class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded text-xs font-bold mt-2">
                                        Save Note
                                    </button>
                                </div>

                                <!-- Activity Timeline -->
                                <div class="space-y-2">
                                    <div class="text-gray-400 text-xs uppercase font-bold mb-2">Activity Timeline</div>
                                    <template x-for="activity in (selectedProperty?.activities || [])" :key="activity.id">
                                        <div class="flex items-start space-x-3 text-xs">
                                            <div class="text-gray-500" x-text="activity.date"></div>
                                            <div class="flex-1">
                                                <div class="text-white" x-text="activity.description"></div>
                                                <div class="text-gray-500 text-[10px]" x-text="activity.type"></div>
                                            </div>
                                        </div>
                                    </template>
                                    <div x-show="!selectedProperty?.activities || selectedProperty.activities.length === 0" 
                                         class="text-gray-500 text-center py-8 text-xs">
                                        No activity recorded yet
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        
        <!-- Footer - Bottom Navigation -->
        <div class="bg-gray-900 border-t border-orange-500 p-2 flex gap-1 flex-shrink-0 fixed bottom-0 left-0 right-0 z-50" style="padding-bottom: calc(0.5rem + env(safe-area-inset-bottom));">
            <button class="flex-1 bg-gray-800 text-orange-500 py-3 px-1 rounded text-[11px] font-bold active:bg-orange-500 active:text-black"
                    @click="filterAbsentee()">
                🏠<br>Absent
            </button>
            <button class="flex-1 bg-gray-800 text-orange-500 py-3 px-1 rounded text-[11px] font-bold active:bg-orange-500 active:text-black"
                    @click="showTagManager()">
                🏷️<br>Tags
            </button>
            <button class="flex-1 bg-gray-800 text-orange-500 py-3 px-1 rounded text-[11px] font-bold active:bg-orange-500 active:text-black cursor-pointer z-10"
                    @click="uploadCSV()" @touchstart="uploadCSV()">
                📁<br>CSV
            </button>
            <button class="flex-1 bg-purple-600 text-white py-3 px-1 rounded text-[11px] font-bold active:bg-purple-800"
                    @click="showFarmOverview()" title="Show aerial view of farm">
                ✈️<br>Aerial
            </button>
            <button class="flex-1 bg-gray-800 text-orange-500 py-3 px-1 rounded text-[11px] font-bold active:bg-orange-500 active:text-black"
                    @click="exportData()">
                📊<br>Export
            </button>
            <button class="flex-1 bg-red-600 text-white py-3 px-1 rounded text-[11px] font-bold active:bg-red-800"
                    @click="showHotList()">
                🔥<br>Hot <span x-text="`(${hotList.length})`"></span>
            </button>
        </div>
        
    </div>  <!-- Close main app container -->
    
    <script>
        function legacyApp() {
            return {
                // Configuration
                MAPBOX_TOKEN: 'pk.eyJ1IjoibGVnYWN5Y29tcGFzcyIsImEiOiJjbWV5MTNkMDAwdGR2Mm1vZTdtNmo4Nm5mIn0.wnWv7lPl2HNZNI8hmUvb1A',
                SUPABASE_URL: 'https://kfomddpbpsaplyucodli.supabase.co',
                SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imtmb21kZHBicHNhcGx5dWNvZGxpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjcxODc2MDAsImV4cCI6MjA0Mjc2MzYwMH0.DLWkTZ-SErpE0doFHMZyUbcFq6TpkLYQSwao8HQML_0',
                
                // App State
                map: null,
                properties: [],
                filteredProperties: [],
                selectedProperty: null,
                detailsTab: 'overview',  // Add this for tab navigation
                hotList: [],
                loading: false,
                currentFarmName: '',
                newPropertyNote: '',
                propertyNotes: {},
                currentUser: null,
                supabase: null,
                markerUpdatePending: false,
                mapMarkers: [],
                isRecording: false,
                mediaRecorder: null,
                audioChunks: [],
                
                // Pagination
                maxDisplayCount: 10000, // Max properties to show at once - increased from 2000
                currentPage: 1,
                totalPages: 1,
                displayedCount: 0,
                paginatedProperties: [],
                
                // Filters
                propertyFilter: 'all', // all, sfr, condo, commercial, multi
                typeCount: {
                    sfr: 0,
                    condo: 0,
                    commercial: 0,
                    multi: 0
                },
                
                // Tagging System
                allTags: new Set(),
                tagFilter: null,
                
                // Map State
                mapSearch: '',
                searchQuery: '',
                showAdvancedFilters: false,
                showTagModal: false,
                newTagName: '',
                selectedTagProperties: [],
                filters: {
                    priceRange: '',
                    beds: '',
                    baths: '',
                    yearBuilt: ''
                },
                propertyTags: {}, // Store tags per property
                mapStyle: 'day',
                is3D: false,
                trafficLayer: null,
                markers: [],
                userMarker: null,
                selectedMarker: null,
                userLocation: null,
                locationWatcher: null,
                
                // Search
                propertySearch: '',
                
                // Stats
                stats: {
                    total: 0,
                    absentee: '0%',
                    avgEquity: '0%'
                },
                
                async init() {
                    console.log('Initializing Legacy Compass...');
                    
                    // For development, always use demo mode
                    localStorage.setItem('demo_mode', 'true');
                    console.log('🎭 Running in demo mode (development)');
                    
                    // Wait for DOM to be ready
                    await this.$nextTick();
                    
                    // Initialize map with a small delay to ensure container is ready
                    setTimeout(() => {
                        this.initMap();
                        this.initGPS();
                    }, 100);
                    
                    // Load saved property notes
                    this.propertyNotes = JSON.parse(localStorage.getItem('property_notes') || '{}');
                    
                    // Check for saved farm in localStorage (for demo mode)
                    const savedFarm = localStorage.getItem('legacy_compass_farm');
                    if (savedFarm) {
                        try {
                            const farmData = JSON.parse(savedFarm);
                            this.properties = farmData.properties || [];
                            this.currentFarmName = farmData.name || 'Saved Farm';
                            this.filteredProperties = [...this.properties];
                            this.updatePagination();
                            this.addMapMarkers();
                            console.log(`✅ Loaded saved farm: ${this.currentFarmName}`);
                        } catch (e) {
                            console.log('No saved farm found');
                        }
                    }
                    
                    this.loading = false;
                    console.log('✅ Legacy Compass ready');
                },
                
                initGPS() {
                    if ('geolocation' in navigator) {
                        console.log('📍 GPS available, starting location tracking...');
                        
                        // Get initial position
                        navigator.geolocation.getCurrentPosition(
                            (position) => {
                                this.updateUserLocation(position);
                                console.log('📍 Initial location:', position.coords.latitude, position.coords.longitude);
                            },
                            (error) => {
                                console.warn('GPS error:', error.message);
                            },
                            { enableHighAccuracy: true }
                        );
                        
                        // Watch position for updates
                        this.locationWatcher = navigator.geolocation.watchPosition(
                            (position) => {
                                this.updateUserLocation(position);
                            },
                            (error) => {
                                console.warn('GPS tracking error:', error.message);
                            },
                            { 
                                enableHighAccuracy: true,
                                maximumAge: 10000,
                                timeout: 5000
                            }
                        );
                    } else {
                        console.log('📍 GPS not available in browser');
                    }
                },
                
                updateUserLocation(position) {
                    this.userLocation = {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude,
                        accuracy: position.coords.accuracy
                    };
                    
                    // Update user marker on map
                    if (this.map) {
                        if (this.userMarker) {
                            this.userMarker.setLngLat([this.userLocation.lng, this.userLocation.lat]);
                        } else {
                            // Create user location marker (blue dot)
                            this.userMarker = new mapboxgl.Marker({
                                element: this.createUserLocationElement(),
                                anchor: 'center'
                            })
                            .setLngLat([this.userLocation.lng, this.userLocation.lat])
                            .addTo(this.map);
                        }
                    }
                    
                    // Find nearest property
                    this.findNearestProperty();
                },
                
                createUserLocationElement() {
                    const el = document.createElement('div');
                    el.className = 'user-location-marker';
                    el.innerHTML = `
                        <div style="width: 20px; height: 20px; background: #007AFF; border: 3px solid white; border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.3); position: relative;">
                            <div style="width: 40px; height: 40px; background: rgba(0, 122, 255, 0.2); border-radius: 50%; position: absolute; top: -10px; left: -10px; animation: pulse 2s infinite;"></div>
                        </div>
                    `;
                    return el;
                },
                
                findNearestProperty() {
                    if (!this.userLocation || this.properties.length === 0) return;
                    
                    let nearest = null;
                    let minDistance = Infinity;
                    
                    this.properties.forEach(prop => {
                        if (prop.lat && prop.lng) {
                            const distance = this.calculateDistance(
                                this.userLocation.lat, this.userLocation.lng,
                                prop.lat, prop.lng
                            );
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearest = prop;
                            }
                        }
                    });
                    
                    if (nearest && minDistance < 100) { // Within 100 meters
                        console.log(`📍 Near property: ${nearest.address} (${Math.round(minDistance)}m away)`);
                        // Could trigger a notification here
                    }
                },
                
                calculateDistance(lat1, lon1, lat2, lon2) {
                    // Haversine formula for distance in meters
                    const R = 6371000; // Earth radius in meters
                    const φ1 = lat1 * Math.PI / 180;
                    const φ2 = lat2 * Math.PI / 180;
                    const Δφ = (lat2 - lat1) * Math.PI / 180;
                    const Δλ = (lon2 - lon1) * Math.PI / 180;
                    
                    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                              Math.cos(φ1) * Math.cos(φ2) *
                              Math.sin(Δλ/2) * Math.sin(Δλ/2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                    
                    return R * c; // Distance in meters
                },
                
                loadMockData() {
                    // DEPRECATED - We don't use mock data anymore
                    console.log('Mock data disabled - use real CSV');
                    return;
                    
                    this.properties = [
                        {
                            id: 1,
                            address: '426 N 86TH LN, Hayward, CA',
                            owner: 'TERESA MARTINEZ',
                            phone: '(602) 555-7100',
                            lat: 37.6688,
                            lng: -122.0808,
                            absentee: true,
                            equity: 76,
                            bedrooms: 3,
                            baths: 2,
                            sqft: 1200,
                            yearBuilt: 1990,
                            type: 'SFR',
                            tags: ['New'],
                            notes: '📝 8/15/2025, 12:49:54 AM — not home'
                        },
                        {
                            id: 2,
                            address: '745 N 91ST AVE, Hayward, CA',
                            owner: 'DANIEL LYONS',
                            phone: '(602) 555-2200',
                            lat: 37.6700,
                            lng: -122.0820,
                            absentee: false,
                            equity: 94,
                            bedrooms: 4,
                            baths: 2.5,
                            sqft: 1800,
                            yearBuilt: 1985,
                            type: 'SFR',
                            tags: ['Follow-up'],
                            notes: ''
                        },
                        {
                            id: 3,
                            address: '301 N 93RD DR, Hayward, CA',
                            owner: 'SHAUKAT BADANI',
                            phone: '',
                            lat: 37.6710,
                            lng: -122.0830,
                            absentee: true,
                            equity: 81,
                            bedrooms: 3,
                            baths: 2,
                            sqft: 1400,
                            yearBuilt: 1995,
                            type: 'SFR',
                            tags: ['Not Interested'],
                            notes: ''
                        },
                        {
                            id: 4,
                            address: '479 W BADEN ST, Hayward, CA',
                            owner: 'MICHAEL SANDLER',
                            phone: '',
                            lat: 37.6720,
                            lng: -122.0840,
                            absentee: false,
                            equity: 40,
                            bedrooms: 2,
                            baths: 1,
                            sqft: 900,
                            yearBuilt: 1975,
                            type: 'SFR',
                            tags: ['Follow-up'],
                            notes: ''
                        },
                        {
                            id: 5,
                            address: '247 N 86TH LN, Hayward, CA',
                            owner: 'CAMILLE CANLAS',
                            phone: '',
                            lat: 37.6730,
                            lng: -122.0850,
                            absentee: true,
                            equity: 58,
                            bedrooms: 3,
                            baths: 2,
                            sqft: 1300,
                            yearBuilt: 1988,
                            type: 'SFR',
                            tags: ['Hot'],
                            notes: ''
                        }
                    ];
                    
                    this.filteredProperties = [...this.properties];
                    this.currentFarmName = 'Demo Properties';
                    this.updatePagination();
                    this.addMapMarkers();
                    this.calculateStats();
                    this.loading = false;
                    
                    // Center map on first property
                    if (this.properties.length > 0) {
                        this.map.flyTo({
                            center: [this.properties[0].lng, this.properties[0].lat],
                            zoom: 15
                        });
                    }
                },
                
                async init() {
                    // Initialize Supabase
                    this.supabase = supabase.createClient(this.SUPABASE_URL, this.SUPABASE_ANON_KEY);
                    
                    // Check for existing session
                    const { data: { session } } = await this.supabase.auth.getSession();
                    if (session) {
                        this.currentUser = session.user;
                    }
                    
                    // Listen for auth changes
                    this.supabase.auth.onAuthStateChange((event, session) => {
                        this.currentUser = session ? session.user : null;
                    });
                    
                    // Initialize the map
                    this.initMap();
                },
                
                initMap() {
                    try {
                        // Set Mapbox access token
                        mapboxgl.accessToken = this.MAPBOX_TOKEN;
                        
                        // Initialize Mapbox GL JS
                        this.map = new mapboxgl.Map({
                            container: 'map',
                            style: 'mapbox://styles/mapbox/streets-v12', // You can change to satellite-streets-v12
                            center: [-122.0808, 37.6688], // Hayward, CA
                            zoom: 15,
                            pitch: 0, // Start flat, then animate to 3D
                            bearing: 0
                        });
                        
                        // Set loading to false once map is ready
                        this.map.on('load', () => {
                            console.log('✅ Map loaded successfully');
                            this.loading = false;
                        });
                        
                        // Handle map errors
                        this.map.on('error', (e) => {
                            console.error('❌ Map error:', e);
                            this.loading = false;
                        });
                    } catch (error) {
                        console.error('❌ Failed to initialize map:', error);
                        this.loading = false;
                    }
                    
                    // Add navigation controls
                    this.map.addControl(new mapboxgl.NavigationControl(), 'top-right');
                    this.map.addControl(new mapboxgl.FullscreenControl(), 'top-right');
                    
                    // Add GPS location control
                    this.geolocateControl = new mapboxgl.GeolocateControl({
                        positionOptions: {
                            enableHighAccuracy: true,
                            timeout: 6000,
                            maximumAge: 0
                        },
                        fitBoundsOptions: {
                            maxZoom: 17
                        },
                        trackUserLocation: true,
                        showUserHeading: true,
                        showUserLocation: true,
                        showAccuracyCircle: true
                    });
                    
                    // Add event listeners for GPS control
                    this.geolocateControl.on('geolocate', (e) => {
                        console.log('📍 GPS Location found:', e.coords.latitude, e.coords.longitude);
                        console.log('Accuracy:', e.coords.accuracy, 'meters');
                        
                        // Fly to user location when GPS is found
                        this.map.flyTo({
                            center: [e.coords.longitude, e.coords.latitude],
                            zoom: 15,
                            bearing: 0,
                            pitch: 0,
                            essential: true
                        });
                    });
                    
                    this.geolocateControl.on('error', (error) => {
                        console.error('❌ GPS Error:', error);
                        if (error && error.code === 1) {
                            console.log('GPS Permission denied');
                        } else if (error && error.code === 2) {
                            console.log('Unable to determine location');
                        } else if (error && error.code === 3) {
                            console.log('Location request timed out');
                        }
                    });
                    
                    this.geolocateControl.on('outofmaxbounds', (e) => {
                        console.log('📍 Location is outside map bounds');
                    });
                    
                    this.map.addControl(this.geolocateControl, 'top-right');
                    
                    // When map loads, enable 3D view
                    this.map.on('load', () => {
                        console.log('✅ Mapbox map loaded successfully');
                        
                        // Add 3D building layer if not already exists
                        if (!this.map.getLayer('3d-buildings')) {
                            this.map.addLayer({
                                'id': '3d-buildings',
                            'source': 'composite',
                            'source-layer': 'building',
                            'filter': ['==', 'extrude', 'true'],
                            'type': 'fill-extrusion',
                            'minzoom': 15,
                            'paint': {
                                'fill-extrusion-color': '#aaa',
                                'fill-extrusion-height': ['get', 'height'],
                                'fill-extrusion-base': ['get', 'min_height'],
                                'fill-extrusion-opacity': 0.6
                            }
                        });
                        }
                        
                        // Test marker removed - markers are working fine now
                        
                        // Animate to 3D view after load
                        setTimeout(() => {
                            this.is3D = true;
                            
                            // Use flyTo for smooth 3D transition
                            this.map.flyTo({
                                pitch: 60,
                                bearing: -17.6,
                                zoom: 16,
                                duration: 2000
                            });
                            
                            console.log('✅ 3D view enabled with pitch: 60°');
                        }, 1000);
                    });
                    
                    // Auto-adjust pitch based on zoom
                    this.map.on('zoom', () => {
                        if (this.is3D) {
                            const zoom = this.map.getZoom();
                            if (zoom > 16) {
                                this.map.setPitch(60);
                            } else if (zoom > 14) {
                                this.map.setPitch(45);
                            } else {
                                this.map.setPitch(30);
                            }
                        }
                    });
                    
                    console.log('Map initialized with Mapbox GL JS');
                },
                
                // Removed duplicate toggleMapStyle - using setMapStyle instead
                
                toggleTraffic() {
                    this.showTraffic = !this.showTraffic;
                    // Traffic layer handled by Mapbox styles
                },
                
                togglePOI() {
                    this.showPOI = !this.showPOI;
                    // POI layer handled by Mapbox styles
                },
                
                setMapStyle(style) {
                    if (!this.map) return;
                    
                    this.mapStyle = style;
                    
                    // Mapbox style URLs
                    const styles = {
                        'day': 'mapbox://styles/mapbox/streets-v12',
                        'dusk': 'mapbox://styles/mapbox/outdoors-v12', 
                        'night': 'mapbox://styles/mapbox/dark-v11',
                        'satellite': 'mapbox://styles/mapbox/satellite-streets-v12'
                    };
                    
                    // Change the main map style
                    this.map.setStyle(styles[style]);
                    
                    // Also update mini map if it exists
                    if (this.miniMapInstance) {
                        this.miniMapInstance.setStyle(styles[style]);
                        
                        // Re-add mini map elements after style change
                        this.miniMapInstance.once('style.load', () => {
                            // Re-add property marker to mini map
                            if (this.selectedProperty && this.selectedProperty.lat && this.selectedProperty.lng) {
                                const el = document.createElement('div');
                                el.className = 'custom-marker';
                                el.style.cssText = `
                                    width: 30px;
                                    height: 30px;
                                    border-radius: 50%;
                                    background: #ff9500;
                                    border: 3px solid white;
                                    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                                    cursor: pointer;
                                `;
                                new mapboxgl.Marker(el)
                                    .setLngLat([this.selectedProperty.lng, this.selectedProperty.lat])
                                    .addTo(this.miniMapInstance);
                            }
                            
                            // Add 3D buildings if not satellite
                            if (style !== 'satellite' && !this.miniMapInstance.getLayer('3d-buildings')) {
                                this.miniMapInstance.addLayer({
                                    'id': '3d-buildings',
                                    'source': 'composite',
                                    'source-layer': 'building',
                                    'filter': ['==', 'extrude', 'true'],
                                    'type': 'fill-extrusion',
                                    'minzoom': 15,
                                    'paint': {
                                        'fill-extrusion-color': style === 'night' ? '#444' : '#aaa',
                                        'fill-extrusion-height': ['get', 'height'],
                                        'fill-extrusion-base': ['get', 'min_height'],
                                        'fill-extrusion-opacity': 0.5
                                    }
                                });
                            }
                        });
                    }
                    
                    // Re-add 3D buildings and markers after style change
                    this.map.once('style.load', () => {
                        if (this.is3D && style !== 'satellite') {
                            this.add3DBuildings();
                        }
                        // Re-add markers after style change
                        setTimeout(() => {
                            this.addMapMarkers();
                        }, 500);
                    });
                },
                
                add3DBuildings() {
                    // Add 3D building layer
                    if (this.map.getLayer('3d-buildings')) {
                        this.map.removeLayer('3d-buildings');
                    }
                    
                    this.map.addLayer({
                        'id': '3d-buildings',
                        'source': 'composite',
                        'source-layer': 'building',
                        'filter': ['==', 'extrude', 'true'],
                        'type': 'fill-extrusion',
                        'minzoom': 15,
                        'paint': {
                            'fill-extrusion-color': this.mapStyle === 'night' ? '#444' : '#aaa',
                            'fill-extrusion-height': ['get', 'height'],
                            'fill-extrusion-base': ['get', 'min_height'],
                            'fill-extrusion-opacity': 0.6
                        }
                    });
                },
                
                toggle3D() {
                    this.is3D = !this.is3D;
                    if (this.is3D) {
                        // Enable 3D view with smooth animation
                        this.map.flyTo({
                            pitch: 60,
                            bearing: -17.6,
                            zoom: this.map.getZoom() > 14 ? this.map.getZoom() : 16,
                            duration: 1500
                        });
                        if (this.mapStyle !== 'satellite') {
                            this.add3DBuildings();
                        }
                        console.log('3D view enabled');
                    } else {
                        // Disable 3D view - return to flat map
                        this.map.flyTo({
                            pitch: 0,
                            bearing: 0,
                            duration: 1500
                        });
                        if (this.map.getLayer('3d-buildings')) {
                            this.map.removeLayer('3d-buildings');
                        }
                        console.log('3D view disabled');
                    }
                },
                
                // Load test data for development
                loadTestData() {
                    console.log('Loading test data for development...');
                    const testProperties = [
                        {
                            id: 1,
                            address: '123 Main St, Hayward, CA',
                            owner: 'John Smith',
                            phone: '510-555-0001',
                            lat: 37.6688,
                            lng: -122.0808,
                            type: 'sfr',
                            absentee: false,
                            equity: 45,
                            bedrooms: 3,
                            baths: 2,
                            sqft: 1500,
                            yearBuilt: 1985,
                            purchasePrice: 350000,
                            purchaseDate: '2015-06-15',
                            tags: [],
                            notes: ''
                        },
                        {
                            id: 2,
                            address: '456 Oak Ave Unit 2B, Hayward, CA',
                            owner: 'Jane Doe',
                            phone: '510-555-0002',
                            lat: 37.6700,
                            lng: -122.0850,
                            type: 'condo',
                            absentee: true,
                            equity: 65,
                            bedrooms: 2,
                            baths: 1,
                            sqft: 900,
                            yearBuilt: 1995,
                            purchasePrice: 275000,
                            purchaseDate: '2010-03-20',
                            tags: ['hot'],
                            notes: 'Absentee owner, high equity'
                        },
                        {
                            id: 3,
                            address: '789 Commercial Blvd, Hayward, CA',
                            owner: 'ABC Corp',
                            phone: '510-555-0003',
                            lat: 37.6650,
                            lng: -122.0780,
                            type: 'commercial',
                            absentee: true,
                            equity: 35,
                            bedrooms: 0,
                            baths: 0,
                            sqft: 5000,
                            yearBuilt: 2000,
                            purchasePrice: 850000,
                            purchaseDate: '2018-11-10',
                            tags: [],
                            notes: ''
                        },
                        {
                            id: 4,
                            address: '321 Duplex Dr, Hayward, CA',
                            owner: 'Bob Johnson',
                            phone: '510-555-0004',
                            lat: 37.6720,
                            lng: -122.0900,
                            type: 'multi',
                            absentee: false,
                            equity: 55,
                            bedrooms: 6,
                            baths: 4,
                            sqft: 2800,
                            yearBuilt: 1975,
                            purchasePrice: 550000,
                            purchaseDate: '2012-08-25',
                            tags: ['contacted'],
                            notes: 'Duplex property, owner occupied'
                        },
                        {
                            id: 5,
                            address: '555 Pine St, Hayward, CA',
                            owner: 'Mary Wilson',
                            phone: '510-555-0005',
                            lat: 37.6640,
                            lng: -122.0820,
                            type: 'sfr',
                            absentee: true,
                            equity: 75,
                            bedrooms: 4,
                            baths: 3,
                            sqft: 2200,
                            yearBuilt: 1990,
                            purchasePrice: 425000,
                            purchaseDate: '2008-05-10',
                            tags: ['hot'],
                            notes: 'High equity opportunity'
                        }
                    ];
                    
                    this.properties = testProperties;
                    this.filteredProperties = [...testProperties];
                    this.updateTypeCounts(testProperties);
                    this.calculateStats();
                    this.loading = false; // Set loading to false first
                    this.updatePagination();
                    
                    console.log('Test data loaded:', testProperties.length, 'properties');
                    console.log('Loading state:', this.loading);
                    console.log('Paginated properties:', this.paginatedProperties);
                    
                    // Force Alpine to update
                    this.$nextTick(() => {
                        console.log('After nextTick - loading:', this.loading);
                        console.log('After nextTick - properties visible:', this.paginatedProperties.length);
                    });
                    
                    // Add markers to map
                    if (this.map) {
                        this.addMapMarkers();
                    }
                },
                
                addTestMarker() {
                    console.log('Adding Mapbox test marker...');
                    try {
                        // Create a red test marker
                        const el = document.createElement('div');
                        el.style.width = '40px';
                        el.style.height = '40px';
                        el.style.backgroundColor = '#FF0000';
                        el.style.border = '3px solid yellow';
                        el.style.borderRadius = '50%';
                        el.style.cursor = 'pointer';
                        el.innerHTML = '<div style="color: white; text-align: center; line-height: 40px; font-weight: bold;">TEST</div>';
                        
                        const testMarker = new mapboxgl.Marker(el)
                            .setLngLat([-122.0808, 37.6688])
                            .setPopup(new mapboxgl.Popup().setHTML('<b>Test Marker Working!</b><br>Mapbox is active'))
                            .addTo(this.map);
                        
                        
                        // Open popup after a delay
                        setTimeout(() => {
                            testMarker.togglePopup();
                        }, 2000);
                        
                    } catch (error) {
                        console.error('❌ Failed to add test marker:', error);
                    }
                },
                
                addMapMarkers() {
                    if (!this.map) {
                        console.error('Map not initialized yet');
                        return;
                    }
                    
                    // Debounce marker updates to prevent performance issues
                    if (this.markerUpdatePending) return;
                    this.markerUpdatePending = true;
                    
                    setTimeout(() => {
                        this.markerUpdatePending = false;
                        this.actuallyAddMarkers();
                    }, 300);
                },
                
                actuallyAddMarkers() {
                    if (!this.map) return;
                    
                    console.log(`Adding markers for ${this.paginatedProperties.length} properties`);
                    
                    // First ensure ALL properties have coordinates (for consistency)
                    let coordsAdded = 0;
                    this.properties.forEach((prop, index) => {
                        if (!prop.lat || !prop.lng || isNaN(prop.lat) || isNaN(prop.lng)) {
                            // Create a grid pattern in Hayward area
                            const row = Math.floor(index / 100);
                            const col = index % 100;
                            // Hayward center: 37.6688, -122.0808
                            // Spread them around Hayward more realistically
                            prop.lat = 37.6688 + (row * 0.002) - 0.1 + (Math.random() * 0.001);
                            prop.lng = -122.0808 + (col * 0.002) - 0.1 + (Math.random() * 0.001);
                            coordsAdded++;
                        }
                    });
                    
                    console.log(`Generated coordinates for ${coordsAdded} properties`);
                    
                    // Use the global function to create markers (avoids Alpine proxy issues)
                    // Show ALL properties on current page (up to 500)
                    const propsToShow = this.paginatedProperties;
                    const markersCreated = window.createPropertyMarkers(this.map, propsToShow, this.markers);
                    console.log(`Marker creation complete: ${markersCreated} markers added for current page`);
                    
                    return; // Exit early - the global function handles everything
                    
                    // Add markers using custom HTML elements for better visibility
                    let markersAdded = 0;
                    const sampleCoords = [];
                    
                    propsToShow.forEach((prop, index) => {
                        // Extract plain values from potentially proxied object
                        const lat = parseFloat(prop.lat);
                        const lng = parseFloat(prop.lng);
                        const address = String(prop.address || '');
                        const owner = String(prop.owner || '');
                        const equity = parseFloat(prop.equity || 0);
                        const phone = String(prop.phone || '');
                        const absentee = Boolean(prop.absentee);
                        
                        if (lat && lng && !isNaN(lat) && !isNaN(lng)) {
                            try {
                                // Log first few coordinates for debugging
                                if (index < 5) {
                                    sampleCoords.push({ 
                                        lat: lat, 
                                        lng: lng, 
                                        address: address,
                                        absentee: absentee 
                                    });
                                }
                                
                                // Determine marker color based on property type
                                let markerColor = '#3b82f6'; // Default blue
                                let markerScale = 0.8;
                                
                                if (absentee) {
                                    markerColor = '#ff6b00'; // Orange for absentee
                                    markerScale = 1;
                                } else if (equity > 50) {
                                    markerColor = '#dc2626'; // Red for high equity
                                    markerScale = 1;
                                }
                                
                                // Create marker with plain values (no proxied objects)
                                const marker = new mapboxgl.Marker({
                                    color: markerColor,
                                    scale: markerScale
                                })
                                .setLngLat([lng, lat])
                                .addTo(this.map);
                                
                                // Create popup HTML with plain values
                                const popupHTML = `
                                    <div style="padding: 8px; min-width: 200px;">
                                        <div style="font-weight: bold; margin-bottom: 4px;">${address}</div>
                                        <div style="color: #666; font-size: 13px;">Owner: ${owner}</div>
                                        <div style="color: #666; font-size: 13px;">Equity: ${equity}%</div>
                                        ${phone ? `<div style="color: #666; font-size: 13px;">Phone: ${phone}</div>` : ''}
                                        ${absentee ? '<div style="color: #ff6b00; font-size: 13px; font-weight: bold;">ABSENTEE OWNER</div>' : ''}
                                    </div>
                                `;
                                
                                // Add popup
                                const popup = new mapboxgl.Popup({ 
                                    offset: [0, -20],
                                    closeButton: true,
                                    closeOnClick: false
                                })
                                .setHTML(popupHTML);
                                
                                marker.setPopup(popup);
                                
                                // Store reference to property index for click handler
                                marker._propertyIndex = index;
                                
                                // Add click handler to marker element after creation
                                const markerElement = marker.getElement();
                                if (markerElement) {
                                    const self = this;
                                    markerElement.addEventListener('click', function() {
                                        // Get fresh reference to property from array
                                        const clickedProp = self.paginatedProperties[marker._propertyIndex];
                                        if (clickedProp) {
                                            self.selectedProperty = clickedProp;
                                        }
                                    });
                                }
                                
                                this.markers.push(marker);
                                markersAdded++;
                            } catch (markerError) {
                                console.error(`Error creating marker ${index}:`, markerError);
                            }
                        }
                    });
                    
                    console.log(`✅ Added ${markersAdded} markers to map`);
                    if (sampleCoords.length > 0) {
                        console.log('Sample marker coordinates:', sampleCoords);
                        console.log('Current map center:', this.map.getCenter());
                        console.log('Current map zoom:', this.map.getZoom());
                    }
                    
                    console.log(`✅ Created ${this.markers.length} markers on map`);
                    
                    // If we have markers, make sure we can see them
                    if (this.markers.length > 0) {
                        const firstMarker = this.markers[0];
                        const lngLat = firstMarker.getLngLat();
                        console.log('First marker at:', lngLat.lng, lngLat.lat);
                    }
                },
                
                updateTypeCounts(properties) {
                    // Reset counts
                    this.typeCount = {
                        sfr: 0,
                        condo: 0,
                        commercial: 0,
                        multi: 0
                    };
                    
                    // Count each type
                    properties.forEach(p => {
                        if (this.typeCount[p.type] !== undefined) {
                            this.typeCount[p.type]++;
                        }
                    });
                },
                
                selectProperty(property) {
                    this.selectedProperty = property;
                    if (property.lat && property.lng) {
                        this.map.flyTo({
                            center: [property.lng, property.lat],
                            zoom: 18
                        });
                    }
                },
                
                focusProperty(property) {
                    this.selectedProperty = property;
                    if (property.lat && property.lng) {
                        // Fly to property with 3D perspective
                        this.map.flyTo({
                            center: [property.lng, property.lat],
                            zoom: 19,
                            pitch: 60,
                            bearing: 41
                        });
                        
                        // Add a pulse animation to the marker
                        const marker = this.markers.find(m => 
                            m.getLngLat().lng === property.lng && 
                            m.getLngLat().lat === property.lat
                        );
                        if (marker) {
                            marker.getElement().classList.add('pulse-animation');
                            setTimeout(() => {
                                marker.getElement().classList.remove('pulse-animation');
                            }, 3000);
                        }
                    } else {
                        alert('No GPS coordinates for this property');
                    }
                },
                
                showPropertyDetails(property) {
                    console.log('=== SHOWING PROPERTY DETAILS ===');
                    console.log('Property:', property);
                    console.log('Address:', property.address);
                    
                    // Make sure we have a valid property object
                    if (!property || !property.address) {
                        console.error('Invalid property object!');
                        return;
                    }
                    
                    // Set the selected property - create a copy to ensure reactivity
                    this.selectedProperty = { ...property };
                    this.detailsTab = 'overview'; // Reset to overview tab
                    
                    // Initialize mini-map after a short delay
                    this.$nextTick(() => {
                        setTimeout(() => {
                            if (this.selectedProperty && this.selectedProperty.lat && this.selectedProperty.lng) {
                                this.initMiniMap(this.selectedProperty.lat, this.selectedProperty.lng);
                            }
                        }, 200);
                    });
                    
                    // Force Alpine to update
                    this.$nextTick(() => {
                        console.log('Selected property after nextTick:', this.selectedProperty);
                        console.log('Details view visible?', !!document.querySelector('[x-show="selectedProperty"]:not([style*="display: none"])'));
                        
                        // Debug: Check what's happening with the panels
                        const listPanel = document.querySelector('[x-show="!selectedProperty"]');
                        const detailsPanel = document.querySelector('[x-show="selectedProperty"]');
                        console.log('List panel hidden?', listPanel?.style.display === 'none');
                        console.log('Details panel visible?', detailsPanel?.style.display !== 'none');
                    });
                    
                    // Focus on the property on the main map
                    if (property.lat && property.lng && this.map) {
                        this.map.flyTo({
                            center: [property.lng, property.lat],
                            zoom: 18,
                            pitch: 45,
                            duration: 1500
                        });
                    }
                },
                
                initMiniMap(lat, lng) {
                    console.log('Initializing mini-map for:', lat, lng);
                    
                    // Wait for container to be visible
                    setTimeout(() => {
                        const miniMapContainer = document.getElementById('mini-map');
                        if (!miniMapContainer || !lat || !lng) {
                            console.error('Mini-map init failed - container:', !!miniMapContainer, 'lat:', lat, 'lng:', lng);
                            return;
                        }
                        
                        // Remove any existing mini map instance
                        if (this.miniMapInstance) {
                            try {
                                this.miniMapInstance.remove();
                            } catch (e) {
                                console.log('Error removing old mini-map:', e);
                            }
                            this.miniMapInstance = null;
                        }
                        
                        // Clear the container
                        miniMapContainer.innerHTML = '';
                        
                        // Get current style for mini map to match main map
                        const styles = {
                            'day': 'mapbox://styles/mapbox/streets-v12',
                            'dusk': 'mapbox://styles/mapbox/outdoors-v12', 
                            'night': 'mapbox://styles/mapbox/dark-v11',
                            'satellite': 'mapbox://styles/mapbox/satellite-streets-v12'
                        };
                        
                        try {
                            // Create interactive Mapbox mini map with same style as main map
                            this.miniMapInstance = new mapboxgl.Map({
                                container: 'mini-map',
                                style: styles[this.mapStyle] || 'mapbox://styles/mapbox/streets-v12',
                                center: [lng, lat],
                                zoom: 16, // Neighborhood zoom level
                                interactive: true,
                                attributionControl: false
                            });
                            
                            // Add zoom controls
                            this.miniMapInstance.addControl(new mapboxgl.NavigationControl({
                            showCompass: false,
                            showZoom: true,
                            visualizePitch: false
                        }), 'top-right');
                        
                        // Wait for map to load
                        this.miniMapInstance.on('load', () => {
                            // Add main property marker
                            const mainMarker = document.createElement('div');
                            mainMarker.style.width = '24px';
                            mainMarker.style.height = '24px';
                            mainMarker.style.borderRadius = '50%';
                            mainMarker.style.backgroundColor = '#ff6b00';
                            mainMarker.style.border = '3px solid white';
                            mainMarker.style.boxShadow = '0 0 10px rgba(255,107,0,0.8)';
                            mainMarker.style.cursor = 'pointer';
                            
                            new mapboxgl.Marker(mainMarker)
                                .setLngLat([lng, lat])
                                .setPopup(new mapboxgl.Popup({ offset: 15 })
                                    .setHTML(`<div style="padding: 6px; font-size: 11px;">
                                        <b>${this.selectedProperty?.address || 'Property'}</b><br>
                                        ${this.selectedProperty?.owner || ''}<br>
                                        Equity: ${this.selectedProperty?.equity || 0}%
                                    </div>`))
                                .addTo(this.miniMapInstance);
                            
                            // Add nearby properties if we have the selected property
                            if (this.selectedProperty) {
                                const nearbyProps = this.properties.filter(p => {
                                    if (!p.lat || !p.lng || p.id === this.selectedProperty.id) return false;
                                    const dist = this.calculateDistance(
                                        lat, lng,
                                        p.lat, p.lng
                                    );
                                    return dist < 250; // Within 250 meters
                                }).slice(0, 15); // Show up to 15 nearby
                            
                            nearbyProps.forEach(nearProp => {
                                const nearMarker = document.createElement('div');
                                nearMarker.style.width = '14px';
                                nearMarker.style.height = '14px';
                                nearMarker.style.borderRadius = '50%';
                                nearMarker.style.backgroundColor = nearProp.absentee ? '#ffa500' : '#4169e1';
                                nearMarker.style.border = '2px solid white';
                                nearMarker.style.opacity = '0.8';
                                nearMarker.style.cursor = 'pointer';
                                
                                new mapboxgl.Marker(nearMarker)
                                    .setLngLat([nearProp.lng, nearProp.lat])
                                    .setPopup(new mapboxgl.Popup({ offset: 10 })
                                        .setHTML(`<div style="padding: 4px; font-size: 10px;">
                                            ${nearProp.address}<br>
                                            ${nearProp.owner}
                                        </div>`))
                                    .addTo(this.miniMapInstance);
                            });
                            
                            // Add 3D buildings if not satellite view
                            if (this.mapStyle !== 'satellite' && !this.miniMapInstance.getLayer('3d-buildings')) {
                                this.miniMapInstance.addLayer({
                                    'id': '3d-buildings',
                                    'source': 'composite',
                                    'source-layer': 'building',
                                    'filter': ['==', 'extrude', 'true'],
                                    'type': 'fill-extrusion',
                                    'minzoom': 15,
                                    'paint': {
                                        'fill-extrusion-color': this.mapStyle === 'night' ? '#444' : '#aaa',
                                        'fill-extrusion-height': ['get', 'height'],
                                        'fill-extrusion-base': ['get', 'min_height'],
                                        'fill-extrusion-opacity': 0.5
                                    }
                                });
                            }
                            }
                        });
                        
                        console.log('Mini map initialized for', this.selectedProperty?.address);
                    } catch (error) {
                        console.error('Mini map error:', error);
                        // Fallback to static display
                        miniMapContainer.innerHTML = `
                            <div class="h-full flex items-center justify-center text-gray-500">
                                <div class="text-center">
                                    <div class="text-2xl mb-1">📍</div>
                                    <div class="text-[10px]">${this.selectedProperty?.address || 'Property'}</div>
                                </div>
                            </div>`;
                    }
                    }, 300); // End of setTimeout
},
                
                flyToProperty(property) {
                    if (!this.map) return;
                    
                    // Ensure property has coordinates
                    if (!property.lat || !property.lng) {
                        const index = this.properties.indexOf(property);
                        const row = Math.floor(index / 70);
                        const col = index % 70;
                        property.lat = 37.6288 + (row * 0.002);
                        property.lng = -122.1208 + (col * 0.002);
                    }
                    
                    // Fly to property location
                    this.map.setCenter([property.lng, property.lat]);
                    this.map.setZoom(18);
                    
                    setTimeout(() => {
                        this.map.easeTo({
                            pitch: 60,
                            bearing: -45,
                            duration: 1000
                        });
                    }, 200);
                    
                    // Add a special marker for selected property
                    if (this.selectedMarker) {
                        this.selectedMarker.remove();
                    }
                    
                    this.selectedMarker = new mapboxgl.Marker({
                        color: '#ff0000',
                        scale: 1.5
                    })
                    .setLngLat([property.lng, property.lat])
                    .addTo(this.map);
                    
                    console.log(`✈️ Flying to: ${property.address}`);
                },
                
                startVoiceNote(property) {
                    if (!property) return;
                    
                    // Set this property as selected for the voice note
                    this.selectedProperty = property;
                    
                    // Use the same voice modal
                    this.showVoiceModal();
                },
                
                stopVoiceRecording() {
                    if (this.recognition) {
                        this.recognition.stop(); // This triggers onend which saves the note
                    }
                },
                
                savePropertyNotes(propertyId, notes) {
                    const property = this.properties.find(p => p.id === propertyId);
                    if (property) {
                        property.notes = notes;
                        this.saveToLocalStorage();
                    }
                },
                
                // Quick action methods
                callProperty(property = null) {
                    const prop = property || this.selectedProperty;
                    if (prop && prop.phone) {
                        window.location.href = `tel:${prop.phone}`;
                    } else {
                        alert('No phone number available for this property');
                    }
                },
                
                textProperty(property = null) {
                    const prop = property || this.selectedProperty;
                    if (prop && prop.phone) {
                        window.location.href = `sms:${prop.phone}`;
                    } else {
                        alert('No phone number available for this property');
                    }
                },
                
                emailProperty(property = null) {
                    const prop = property || this.selectedProperty;
                    if (prop) {
                        const subject = encodeURIComponent(`Regarding ${prop.address}`);
                        window.location.href = `mailto:?subject=${subject}`;
                    }
                },
                
                routeToProperty(property = null) {
                    const prop = property || this.selectedProperty;
                    if (prop) {
                        const address = encodeURIComponent(prop.address);
                        window.open(`https://maps.google.com/?q=${address}`, '_blank');
                    }
                },
                
                mailerProperty(property = null) {
                    const prop = property || this.selectedProperty;
                    if (prop) {
                        alert(`Mailer feature coming soon for:\n${prop.address}`);
                    }
                },
                
                addQuickNote(property, note) {
                    if (property && note && note.trim()) {
                        const timestamp = new Date().toLocaleString();
                        const newNote = `📝 ${timestamp} — ${note.trim()}`;
                        property.notes = property.notes ? 
                            `${property.notes}\n${newNote}` : newNote;
                        this.saveToLocalStorage();
                    }
                },
                
                addPropertyNote() {
                    if (this.selectedProperty && this.newPropertyNote.trim()) {
                        const timestamp = new Date().toLocaleString();
                        const newNote = `📝 ${timestamp} — ${this.newPropertyNote.trim()}`;
                        this.selectedProperty.notes = this.selectedProperty.notes ? 
                            `${this.selectedProperty.notes}\n${newNote}` : newNote;
                        this.newPropertyNote = '';
                        this.saveToLocalStorage();
                    }
                },
                
                filterProperties() {
                    const search = this.propertySearch.toLowerCase();
                    let filtered = [...this.properties];
                    
                    // Apply text search
                    if (search) {
                        filtered = filtered.filter(p => 
                            p.address.toLowerCase().includes(search) ||
                            p.owner.toLowerCase().includes(search)
                        );
                    }
                    
                    // Apply property type filter
                    if (this.propertyFilter !== 'all') {
                        filtered = filtered.filter(p => p.type === this.propertyFilter);
                    }
                    
                    // Apply tag filter
                    if (this.tagFilter) {
                        filtered = filtered.filter(p => 
                            p.tags && p.tags.includes(this.tagFilter)
                        );
                    }
                    
                    this.filteredProperties = filtered;
                    this.updatePagination();
                    this.addMapMarkers();
                },
                
                searchAddress() {
                    if (!this.searchQuery || !this.map) return;
                    
                    // Check if searching for a tag
                    if (this.searchQuery.startsWith('#')) {
                        const tagToSearch = this.searchQuery.substring(1).toLowerCase();
                        this.propertySearch = this.searchQuery;
                        this.filterProperties();
                        return;
                    }
                    
                    // Otherwise search for address/location
                    fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(this.searchQuery)}.json?access_token=${mapboxgl.accessToken}`)
                        .then(response => response.json())
                        .then(data => {
                            if (data.features && data.features.length > 0) {
                                const [lng, lat] = data.features[0].center;
                                
                                // Fly to the location
                                this.map.flyTo({
                                    center: [lng, lat],
                                    zoom: 16,
                                    pitch: 45,
                                    bearing: 0,
                                    duration: 2000
                                });
                                
                                // Add a temporary marker
                                const el = document.createElement('div');
                                el.style.cssText = `
                                    width: 30px;
                                    height: 30px;
                                    background: #3b82f6;
                                    border-radius: 50%;
                                    border: 3px solid white;
                                    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                                `;
                                
                                new mapboxgl.Marker(el)
                                    .setLngLat([lng, lat])
                                    .setPopup(new mapboxgl.Popup().setHTML(`<div class="p-2"><strong>📍 ${this.searchQuery}</strong></div>`))
                                    .addTo(this.map);
                                    
                                // Clear search
                                setTimeout(() => {
                                    this.searchQuery = '';
                                }, 2000);
                            } else {
                                alert('Location not found. Try a different search.');
                            }
                        })
                        .catch(error => {
                            console.error('Search error:', error);
                            alert('Error searching for location');
                        });
                },
                
                showTagManager() {
                    alert('Tag manager coming soon! You can tag properties by typing #tagname in the search bar.');
                },
                
                applyFilters() {
                    this.filterProperties();
                    // Limit to 2000 properties max for performance
                    if (this.filteredProperties.length > 2000) {
                        const wasMore = this.filteredProperties.length;
                        this.filteredProperties = this.filteredProperties.slice(0, 2000);
                        console.log(`Limited display from ${wasMore} to 2000 properties`);
                    }
                    this.updatePagination();
                    this.addMapMarkers();
                },
                
                filterByType(type) {
                    console.log('Filtering by type:', type);
                    this.propertyFilter = type;
                    this.currentPage = 1;
                    
                    // Check what types are in the data
                    if (type !== 'all') {
                        const typeCounts = {};
                        this.properties.forEach(p => {
                            const pType = p.type || 'unknown';
                            typeCounts[pType] = (typeCounts[pType] || 0) + 1;
                        });
                        console.log('Property types in data:', typeCounts);
                    }
                    
                    this.filterProperties();
                    console.log('Filtered count:', this.filteredProperties.length);
                },
                
                filterByTag(tag) {
                    this.tagFilter = tag;
                    this.currentPage = 1;
                    this.filterProperties();
                    alert(`Filtering by tag: ${tag}\nClick 'ALL' to clear filter`);
                },
                
                async logout() {
                    if (this.supabase) {
                        await this.supabase.auth.signOut();
                    }
                    localStorage.removeItem('demo_mode');
                    localStorage.removeItem('legacy_compass_farm');
                    window.location.href = '/login.html';
                },

                async loadUserData() {
                    if (!this.supabase || !this.currentUser) return;
                    
                    try {
                        // Load user's properties from Supabase
                        const { data, error } = await this.supabase
                            .from('user_properties')
                            .select('*')
                            .eq('user_id', this.currentUser.id);
                        
                        if (!error && data) {
                            console.log(`Loaded ${data.length} properties from cloud`);
                            // Convert Supabase data to our format
                            this.properties = data.map(p => ({
                                id: p.property_id,
                                address: p.property_address,
                                owner: p.owner_name,
                                phone: p.phone,
                                email: p.email,
                                notes: p.notes,
                                tags: p.tags || [],
                                lat: p.latitude,
                                lng: p.longitude,
                                equity: p.equity || 0,
                                absentee: p.is_absentee || false,
                                mailingAddress: p.mailing_address,
                                purchasePrice: p.purchase_price,
                                purchaseDate: p.purchase_date
                            }));
                            this.filteredProperties = [...this.properties];
                            this.updatePagination();
                            this.addMapMarkers();
                        }
                    } catch (error) {
                        console.error('Error loading user data:', error);
                    }
                },

                async savePropertyToCloud(property) {
                    if (!this.supabase || !this.currentUser) return;
                    
                    try {
                        const { data, error } = await this.supabase
                            .from('user_properties')
                            .upsert({
                                user_id: this.currentUser.id,
                                property_id: property.id,
                                property_address: property.address,
                                owner_name: property.owner,
                                phone: property.phone,
                                email: property.email,
                                notes: property.notes,
                                tags: property.tags,
                                latitude: property.lat,
                                longitude: property.lng,
                                equity: property.equity,
                                is_absentee: property.absentee,
                                mailing_address: property.mailingAddress,
                                purchase_price: property.purchasePrice,
                                purchase_date: property.purchaseDate
                            }, {
                                onConflict: 'user_id,property_id'
                            });
                        
                        if (error) {
                            console.error('Error saving to cloud:', error);
                        } else {
                            console.log('Property saved to cloud');
                        }
                    } catch (error) {
                        console.error('Error saving property:', error);
                    }
                },

                updatePagination() {
                    this.totalPages = Math.ceil(this.filteredProperties.length / this.maxDisplayCount);
                    this.currentPage = Math.min(this.currentPage, Math.max(1, this.totalPages));
                    
                    const start = (this.currentPage - 1) * this.maxDisplayCount;
                    const end = start + this.maxDisplayCount;
                    
                    this.paginatedProperties = this.filteredProperties.slice(start, end);
                    this.displayedCount = this.paginatedProperties.length;
                    
                    console.log('Updated pagination:', {
                        total: this.filteredProperties.length,
                        paginated: this.paginatedProperties.length,
                        currentPage: this.currentPage,
                        totalPages: this.totalPages
                    });
                },
                
                nextPage() {
                    if (this.currentPage < this.totalPages) {
                        this.currentPage++;
                        this.updatePagination();
                        this.addMapMarkers();
                    }
                },
                
                previousPage() {
                    if (this.currentPage > 1) {
                        this.currentPage--;
                        this.updatePagination();
                        this.addMapMarkers();
                    }
                },
                
                addTag(property, tag) {
                    if (!tag || tag.trim() === '') return;
                    
                    tag = tag.trim().toLowerCase();
                    
                    // Initialize tags array if it doesn't exist
                    if (!property.tags) {
                        property.tags = [];
                    }
                    
                    // Add tag if not already present
                    if (!property.tags.includes(tag)) {
                        property.tags.push(tag);
                        this.allTags.add(tag);
                        
                        // Save to localStorage
                        this.savePropertyTags();
                        
                        console.log(`Tagged ${property.address} with: ${tag}`);
                    }
                },
                
                savePropertyTags() {
                    // Save tags to localStorage for persistence
                    const tagData = {};
                    this.properties.forEach(p => {
                        if (p.tags && p.tags.length > 0) {
                            tagData[p.id] = p.tags;
                        }
                    });
                    localStorage.setItem('propertyTags', JSON.stringify(tagData));
                },
                
                loadPropertyTags() {
                    // Load tags from localStorage
                    const tagData = localStorage.getItem('propertyTags');
                    if (tagData) {
                        const tags = JSON.parse(tagData);
                        this.properties.forEach(p => {
                            if (tags[p.id]) {
                                p.tags = tags[p.id];
                                tags[p.id].forEach(tag => this.allTags.add(tag));
                            }
                        });
                    }
                },
                
                detectPropertyType(property) {
                    // Auto-detect property type based on address or other fields
                    const address = (property.address || '').toLowerCase();
                    const propType = (property.property_type || property.type || '').toLowerCase();
                    
                    if (propType.includes('condo') || address.includes('unit') || address.includes('apt')) {
                        return 'condo';
                    } else if (propType.includes('commercial') || propType.includes('retail') || propType.includes('office')) {
                        return 'commercial';
                    } else if (propType.includes('multi') || propType.includes('duplex') || propType.includes('triplex')) {
                        return 'multi';
                    } else {
                        return 'sfr'; // Default to single family
                    }
                },
                
                filterAbsentee() {
                    this.filteredProperties = this.properties.filter(p => p.absentee);
                    this.addMapMarkers();
                },
                
                calculateStats() {
                    this.stats.total = this.properties.length;
                    const absenteeCount = this.properties.filter(p => p.absentee).length;
                    this.stats.absentee = this.stats.total > 0 ? Math.round((absenteeCount / this.stats.total) * 100) : 0;
                    
                    const avgEquity = this.stats.total > 0 ? 
                        this.properties.reduce((sum, p) => sum + (p.equity || 0), 0) / this.stats.total : 0;
                    this.stats.avgEquity = Math.round(avgEquity);
                    
                    // Count property types
                    this.typeCount = {
                        sfr: 0,
                        condo: 0,
                        commercial: 0,
                        multi: 0
                    };
                    
                    this.properties.forEach(p => {
                        const type = (p.type || 'sfr').toLowerCase();
                        if (this.typeCount.hasOwnProperty(type)) {
                            this.typeCount[type]++;
                        } else {
                            this.typeCount.sfr++; // Default to sfr if unknown
                        }
                    });
                },
                
                searchLocation() {
                    console.log('Searching for:', this.mapSearch);
                    // Implement Mapbox geocoding search
                },
                
                uploadCSV() {
                    console.log('uploadCSV button clicked!');
                    // Create file input element
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.csv';
                    
                    input.onchange = async (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        
                        this.loading = true;
                        
                        try {
                            // Read file content
                            const text = await file.text();
                            
                            // Parse CSV
                            const parsed = this.parseCSV(text);
                            
                            if (parsed && parsed.length > 0) {
                                // Update properties
                                this.properties = parsed;
                                this.filteredProperties = [...this.properties];
                                
                                // Update pagination
                                this.currentPage = 1;
                                this.updatePagination();
                                
                                // Load any saved tags for these properties
                                this.loadPropertyTags();
                                
                                // Calculate stats first
                                this.calculateStats();
                                
                                // Save farm name
                                this.currentFarmName = file.name.replace('.csv', '').replace(/_/g, ' ');
                                
                                // Save to localStorage for persistence
                                try {
                                    const farmData = {
                                        name: this.currentFarmName,
                                        properties: parsed.slice(0, 2000), // Save first 2000 for performance
                                        savedAt: new Date().toISOString()
                                    };
                                    localStorage.setItem('legacy_compass_farm', JSON.stringify(farmData));
                                    console.log('✅ Farm saved to browser storage');
                                } catch (e) {
                                    console.log('Could not save to localStorage:', e);
                                }
                                
                                // Ensure all properties have coordinates IMMEDIATELY
                                let generatedCoords = 0;
                                this.properties.forEach((prop, index) => {
                                    if (!prop.lat || !prop.lng || isNaN(prop.lat) || isNaN(prop.lng)) {
                                        const row = Math.floor(index / 70);
                                        const col = index % 70;
                                        prop.lat = 37.6288 + (row * 0.002);
                                        prop.lng = -122.1208 + (col * 0.002);
                                        generatedCoords++;
                                    }
                                });
                                
                                console.log(`Generated coordinates for ${generatedCoords} properties`);
                                
                                // Add markers and center map on farm
                                setTimeout(() => {
                                    // Update markers on map
                                    this.addMapMarkers();
                                    
                                    // Automatically show aerial view of farm
                                    console.log('Triggering aerial view after CSV load...');
                                    this.showFarmOverview();
                                }, 2000); // Wait longer for map to be fully ready
                                
                                // Show detailed success info
                                const withCoords = parsed.filter(p => p.lat && p.lng).length;
                                const absenteeCount = parsed.filter(p => p.absentee).length;
                                
                                console.log(`✅ CSV Load Success:
                                    Total properties: ${parsed.length}
                                    Properties with GPS: ${withCoords}
                                    Absentee owners: ${absenteeCount}
                                    File: ${file.name}`);
                                
                                // Show success briefly then auto-close
                                const successMsg = `✅ Successfully loaded ${parsed.length} properties!
                                    
${withCoords} have GPS coordinates
${absenteeCount} are absentee owned
                                    
Farm: ${this.currentFarmName}`;
                                
                                console.log(successMsg);
                                
                                // Use a temporary notification instead of alert
                                const notification = document.createElement('div');
                                notification.innerHTML = `
                                    <div style="position: fixed; top: 20px; right: 20px; background: #10b981; color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 9999; max-width: 300px;">
                                        <div style="font-weight: bold; margin-bottom: 8px;">✅ Successfully loaded ${parsed.length} properties!</div>
                                        <div style="font-size: 14px; opacity: 0.9;">
                                            ${withCoords} have GPS coordinates<br>
                                            ${absenteeCount} are absentee owned<br>
                                            Farm: ${this.currentFarmName}
                                        </div>
                                    </div>
                                `;
                                document.body.appendChild(notification);
                                
                                // Auto-remove after 3 seconds
                                setTimeout(() => {
                                    notification.remove();
                                }, 3000);
                            } else {
                                console.error('No properties found in CSV or parsing failed');
                                alert('No properties found in CSV file. Please check the format and headers.');
                            }
                        } catch (error) {
                            console.error('CSV parsing error (may be recoverable):', error);
                            // Don't show alert for minor parsing errors if we got some data
                            if (!parsed || parsed.length === 0) {
                                alert(`Error loading CSV: ${error.message || 'Please check the file format'}`);
                            }
                        } finally {
                            this.loading = false;
                        }
                    };
                    
                    // Trigger file selection
                    input.click();
                },
                
                parseCSV(text) {
                    try {
                        console.log('Parsing CSV, text length:', text.length);
                        
                        if (!text || text.trim().length === 0) {
                            throw new Error('CSV content is empty');
                        }
                        
                        // Handle different line endings
                        const lines = text.split(/\r?\n/).filter(line => line.trim());
                        console.log('Found', lines.length, 'lines in CSV');
                        
                        if (lines.length < 2) {
                            throw new Error('CSV has less than 2 lines (need header + data)');
                        }
                        
                        // Parse headers - handle quoted fields
                        const headers = this.parseCSVLine(lines[0]);
                        console.log('Headers found:', headers);
                        
                        if (headers.length === 0) {
                            throw new Error('No headers found in CSV');
                        }
                    
                    // Find column indices for Jeff's CSV format - check exact header names from file
                    console.log('Looking for columns in headers:', headers.slice(0, 10)); // Show first 10 headers
                    
                    const columnMap = {
                        address: this.findColumn(headers, ['Site Address', 'site address', 'address', 'property_address', 'property address', 'Property Address']),
                        owner: this.findColumn(headers, ['All Owners', 'all owners', 'owner', 'owner_name', '1st Owner\'s Last Name', 'Owner Name']),
                        firstName: this.findColumn(headers, ['1st Owner\'s First Name', 'first name', 'First Name']),
                        lastName: this.findColumn(headers, ['1st Owner\'s Last Name', 'last name', 'Last Name']),
                        phone: this.findColumn(headers, ['phone', 'phone_number', 'phone number', 'contact', 'Phone']),
                        lat: this.findColumn(headers, ['Latitude', 'latitude', 'lat', 'y', 'LAT']),
                        lng: this.findColumn(headers, ['Longitude', 'longitude', 'lng', 'lon', 'x', 'LONG', 'LNG']),
                        absentee: this.findColumn(headers, ['Owner Occupied', 'owner occupied', 'absentee', 'absent', 'Absentee']),
                        equity: this.findColumn(headers, ['equity', 'equity_percent', 'equity %', 'Equity']),
                        // Additional fields from Jeff's CSV
                        city: this.findColumn(headers, ['Site City', 'site city', 'city', 'City']),
                        bedrooms: this.findColumn(headers, ['Bedrooms', 'bedrooms', 'beds', 'Beds']),
                        baths: this.findColumn(headers, ['Baths', 'baths', 'bathrooms', 'Bathrooms']),
                        sqft: this.findColumn(headers, ['Building Size', 'building size', 'sqft', 'Square Feet', 'SQFT']),
                        yearBuilt: this.findColumn(headers, ['Year Built', 'year built', 'year', 'YearBuilt']),
                        purchasePrice: this.findColumn(headers, ['Purchase Price', 'purchase price', 'price', 'Sale Price']),
                        purchaseDate: this.findColumn(headers, ['Purchase Date', 'purchase date', 'date', 'Sale Date']),
                        // Mailing address fields
                        mailAddress: this.findColumn(headers, ['Mail Address', 'mail address', 'Mailing Address', 'mailing address']),
                        mailCity: this.findColumn(headers, ['Mailing City', 'mailing city', 'Mail City']),
                        mailState: this.findColumn(headers, ['Mailing State', 'mailing state', 'Mail State']),
                        mailZip: this.findColumn(headers, ['Mailing Zip Code', 'mailing zip', 'Mail Zip'])
                    };
                    
                    // Log column mapping for debugging
                    console.log('Column mapping:', columnMap);
                    
                    // Parse data rows
                    const parsedData = [];
                    let successCount = 0;
                    let errorCount = 0;
                    
                    for (let i = 1; i < lines.length; i++) {
                        try {
                            const line = lines[i];
                            if (!line.trim()) continue; // Skip empty lines
                            
                            const values = this.parseCSVLine(line);
                            
                            // Skip rows that don't have enough columns
                            if (values.length < headers.length / 2) {
                                console.warn(`Skipping row ${i}: insufficient columns`);
                                errorCount++;
                                continue;
                            }
                            
                            // Safely get values with bounds checking
                            const getValue = (index) => {
                                return (index >= 0 && index < values.length) ? values[index] : '';
                            };
                            
                            // Build owner name from first/last or use All Owners
                            let ownerName = getValue(columnMap.owner);
                            if (!ownerName || ownerName === 'Unknown Owner') {
                                const firstName = getValue(columnMap.firstName);
                                const lastName = getValue(columnMap.lastName);
                                if (firstName || lastName) {
                                    ownerName = `${firstName} ${lastName}`.trim();
                                }
                            }
                            
                            // Build mailing address
                            const mailAddress = getValue(columnMap.mailAddress);
                            const mailCity = getValue(columnMap.mailCity);
                            const mailState = getValue(columnMap.mailState);
                            const mailZip = getValue(columnMap.mailZip);
                            let fullMailingAddress = '';
                            if (mailAddress) {
                                fullMailingAddress = mailAddress;
                                if (mailCity || mailState || mailZip) {
                                    fullMailingAddress += `, ${mailCity || ''} ${mailState || ''} ${mailZip || ''}`.replace(/\s+/g, ' ').trim();
                                }
                            }
                            
                            const property = {
                                id: parsedData.length + 1,
                                address: getValue(columnMap.address) || 'Unknown Address',
                                owner: ownerName || 'Unknown Owner',
                                phone: getValue(columnMap.phone) || '',
                                mailingAddress: fullMailingAddress,
                                lat: parseFloat(getValue(columnMap.lat)) || null,
                                lng: parseFloat(getValue(columnMap.lng)) || null,
                                // Owner Occupied = N means absentee owner
                                absentee: getValue(columnMap.absentee) === 'N' || getValue(columnMap.absentee) === 'false',
                                // Calculate equity based on purchase price and current value
                                purchasePrice: parseFloat(getValue(columnMap.purchasePrice)) || 0,
                                purchaseDate: getValue(columnMap.purchaseDate) || '',
                                // Calculate realistic equity based on purchase price and estimated current value
                                equity: (() => {
                                    const price = parseFloat(getValue(columnMap.purchasePrice)) || 0;
                                    if (price > 0) {
                                        // Estimate 5-8% appreciation per year since purchase
                                        const purchaseYear = getValue(columnMap.purchaseDate) ? new Date(getValue(columnMap.purchaseDate)).getFullYear() : 2010;
                                        const yearsOwned = 2025 - purchaseYear;
                                        const appreciation = 1 + (0.06 * yearsOwned); // 6% per year average
                                        const currentValue = price * appreciation;
                                        const equity = Math.min(95, Math.floor(((currentValue - price) / currentValue) * 100));
                                        return equity > 0 ? equity : Math.floor(Math.random() * 30) + 20;
                                    }
                                    return Math.floor(Math.random() * 30) + 20; // Random 20-50% if no price
                                })(),
                                // Additional fields
                                city: getValue(columnMap.city) || 'Hayward',
                                bedrooms: parseInt(getValue(columnMap.bedrooms)) || 0,
                                baths: parseFloat(getValue(columnMap.baths)) || 0,
                                sqft: parseInt(getValue(columnMap.sqft)) || 0,
                                yearBuilt: parseInt(getValue(columnMap.yearBuilt)) || 0,
                                purchasePrice: parseInt(getValue(columnMap.purchasePrice)) || 0,
                                purchaseDate: getValue(columnMap.purchaseDate) || '',
                                tags: [],
                                notes: '',
                                // Keep all original data
                                ...this.parseRow(headers, values)
                            };
                            
                            // Auto-detect property type
                            property.type = this.detectPropertyType(property);
                            
                            parsedData.push(property);
                            successCount++;
                            
                            // Log first few properties for debugging
                            if (parsedData.length <= 3) {
                                console.log(`Property ${parsedData.length}:`, property);
                            }
                        } catch (rowError) {
                            console.error(`Error parsing row ${i}:`, rowError);
                            errorCount++;
                        }
                    }
                    
                    console.log(`Parse results: ${successCount} successful, ${errorCount} errors`);
                    
                    // Count property types
                    this.updateTypeCounts(parsedData);
                    
                    console.log('✅ Successfully parsed', parsedData.length, 'properties');
                    return parsedData;
                        
                    } catch (error) {
                        console.error('Error parsing CSV:', error);
                        throw new Error(`CSV parsing failed: ${error.message}`);
                    }
                },
                
                findColumn(headers, possibleNames) {
                    if (!headers || headers.length === 0) return 0;
                    
                    const lowerHeaders = headers.map(h => (h || '').toString().toLowerCase().trim());
                    
                    for (const name of possibleNames) {
                        if (!name) continue;
                        const searchName = name.toLowerCase().trim();
                        const index = lowerHeaders.indexOf(searchName);
                        if (index !== -1) {
                            console.log(`Found column "${name}" at index ${index}`);
                            return index;
                        }
                    }
                    
                    console.log(`No match found for columns: ${possibleNames.join(', ')}`);
                    return 0; // Default to first column if not found
                },
                
                parseBoolean(value) {
                    if (!value) return false;
                    const lower = value.toLowerCase();
                    return lower === 'true' || lower === 'yes' || lower === '1' || lower === 'y';
                },
                
                parseRow(headers, values) {
                    const row = {};
                    headers.forEach((header, i) => {
                        row[header] = values[i] || '';
                    });
                    return row;
                },
                
                parseCSVLine(line) {
                    // Handle CSV lines with quoted fields containing commas
                    const result = [];
                    let current = '';
                    let inQuotes = false;
                    
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        const nextChar = line[i + 1];
                        
                        if (char === '"') {
                            if (inQuotes && nextChar === '"') {
                                // Escaped quote
                                current += '"';
                                i++; // Skip next quote
                            } else {
                                // Toggle quote state
                                inQuotes = !inQuotes;
                            }
                        } else if (char === ',' && !inQuotes) {
                            // End of field
                            result.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    
                    // Add last field
                    result.push(current.trim());
                    
                    return result;
                },
                
                exportData() {
                    console.log('exportData button clicked!');
                    if (this.filteredProperties.length === 0) {
                        alert('No properties to export');
                        return;
                    }
                    
                    // Create CSV content
                    const headers = ['Address', 'Owner', 'Phone', 'Latitude', 'Longitude', 'Absentee', 'Equity %'];
                    const rows = this.filteredProperties.map(p => [
                        p.address,
                        p.owner,
                        p.phone || '',
                        p.lat || '',
                        p.lng || '',
                        p.absentee ? 'Yes' : 'No',
                        p.equity || 0
                    ]);
                    
                    // Combine headers and rows
                    const csvContent = [
                        headers.join(','),
                        ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
                    ].join('\n');
                    
                    // Create download link
                    const blob = new Blob([csvContent], { type: 'text/csv' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `legacy-compass-export-${new Date().toISOString().split('T')[0]}.csv`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    console.log(`✅ Exported ${this.filteredProperties.length} properties`);
                },
                
                showHotList() {
                    console.log('showHotList button clicked!');
                    // Filter properties with high equity (>50%) and absentee owners
                    this.hotList = this.properties.filter(p => 
                        p.absentee && p.equity > 50
                    );
                    
                    if (this.hotList.length === 0) {
                        alert('No hot properties found!\n\nHot properties are absentee-owned with >50% equity.');
                        return;
                    }
                    
                    // Update filtered view to show only hot list
                    this.filteredProperties = [...this.hotList];
                    this.addMapMarkers();
                    
                    // Show notification
                    alert(`🔥 Found ${this.hotList.length} hot properties!\n\nThese are absentee-owned with >50% equity.`);
                    
                    // Zoom to show all hot properties
                    if (this.hotList.length > 0 && this.map) {
                        const bounds = new mapboxgl.LngLatBounds();
                        this.hotList.forEach(prop => {
                            if (prop.lat && prop.lng) {
                                bounds.extend([prop.lng, prop.lat]);
                            }
                        });
                        
                        if (!bounds.isEmpty()) {
                            this.map.fitBounds(bounds, { padding: 50 });
                        }
                    }
                },
                
                showDriveTimeArea(minutes) {
                    console.log(`⏱️ Showing properties within ${minutes} minute drive`);
                    
                    if (!navigator.geolocation) {
                        alert('GPS location is required for drive time calculation');
                        return;
                    }
                    
                    // Get current location
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const userLat = position.coords.latitude;
                            const userLng = position.coords.longitude;
                            
                            // Calculate approximate drive distance (rough estimate)
                            // Assuming average speed of 30 mph in city = 0.5 miles per minute
                            const milesRadius = minutes * 0.5;
                            const metersRadius = milesRadius * 1609.34;
                            
                            // Filter properties within drive time
                            const nearbyProperties = this.properties.filter(prop => {
                                if (!prop.lat || !prop.lng) return false;
                                const distance = this.calculateDistance(userLat, userLng, prop.lat, prop.lng);
                                return distance <= metersRadius;
                            });
                            
                            // Update filtered properties
                            this.filteredProperties = nearbyProperties;
                            this.currentPage = 1;
                            this.updatePagination();
                            this.addMapMarkers();
                            
                            // Draw circle on map to show drive area
                            if (this.driveTimeCircle) {
                                this.map.removeLayer('drive-time-circle');
                                this.map.removeSource('drive-time-circle');
                            }
                            
                            // Add circle to show drive time area
                            this.map.addSource('drive-time-circle', {
                                'type': 'geojson',
                                'data': {
                                    'type': 'Feature',
                                    'geometry': {
                                        'type': 'Point',
                                        'coordinates': [userLng, userLat]
                                    }
                                }
                            });
                            
                            this.map.addLayer({
                                'id': 'drive-time-circle',
                                'type': 'circle',
                                'source': 'drive-time-circle',
                                'paint': {
                                    'circle-radius': {
                                        'base': 1.75,
                                        'stops': [
                                            [0, 0],
                                            [20, metersRadius]
                                        ]
                                    },
                                    'circle-color': 'rgba(66, 133, 244, 0.2)',
                                    'circle-stroke-color': '#4285F4',
                                    'circle-stroke-width': 2,
                                    'circle-stroke-opacity': 0.8
                                }
                            });
                            
                            this.driveTimeCircle = true;
                            
                            // Fly to show the area
                            const bounds = new mapboxgl.LngLatBounds();
                            bounds.extend([userLng - (milesRadius * 0.02), userLat - (milesRadius * 0.015)]);
                            bounds.extend([userLng + (milesRadius * 0.02), userLat + (milesRadius * 0.015)]);
                            
                            this.map.fitBounds(bounds, {
                                padding: 50,
                                duration: 1500
                            });
                            
                            alert(`Found ${nearbyProperties.length} properties within ${minutes} minute drive\n\nShowing only these properties on the map.`);
                        },
                        (error) => {
                            alert('Please enable GPS to use drive time feature');
                        },
                        { enableHighAccuracy: true }
                    );
                },
                
                goToMyLocation() {
                    console.log('📍 Getting current GPS location...');
                    
                    if (!this.map) {
                        alert('Map not ready yet.');
                        return;
                    }
                    
                    // Check if geolocation is available
                    if (!navigator.geolocation) {
                        alert('GPS location is not available in your browser');
                        return;
                    }
                    
                    // Get current position
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            const lat = position.coords.latitude;
                            const lng = position.coords.longitude;
                            const accuracy = position.coords.accuracy;
                            
                            console.log(`📍 Your location: ${lat}, ${lng} (accuracy: ${accuracy}m)`);
                            
                            // Fly to user location with a slight delay to ensure it happens
                            setTimeout(() => {
                                this.map.flyTo({
                                    center: [lng, lat],
                                    zoom: 16,
                                    pitch: 45,
                                    bearing: 0,
                                    duration: 2000,
                                    essential: true  // This animation is essential with respect to prefers-reduced-motion
                                });
                                
                                console.log('🚀 Flying to GPS location:', lat, lng);
                            }, 100);
                            
                            // Add or update user location marker
                            if (this.userLocationMarker) {
                                this.userLocationMarker.setLngLat([lng, lat]);
                            } else {
                                // Create a pulsing dot for user location
                                const el = document.createElement('div');
                                el.style.width = '20px';
                                el.style.height = '20px';
                                el.style.borderRadius = '50%';
                                el.style.background = '#4285F4';
                                el.style.border = '3px solid white';
                                el.style.boxShadow = '0 0 0 10px rgba(66, 133, 244, 0.3)';
                                el.style.animation = 'pulse 2s infinite';
                                
                                // Add pulse animation if not exists
                                if (!document.getElementById('pulse-style')) {
                                    const style = document.createElement('style');
                                    style.id = 'pulse-style';
                                    style.textContent = `
                                        @keyframes pulse {
                                            0% { box-shadow: 0 0 0 0 rgba(66, 133, 244, 0.7); }
                                            70% { box-shadow: 0 0 0 20px rgba(66, 133, 244, 0); }
                                            100% { box-shadow: 0 0 0 0 rgba(66, 133, 244, 0); }
                                        }
                                    `;
                                    document.head.appendChild(style);
                                }
                                
                                this.userLocationMarker = new mapboxgl.Marker(el)
                                    .setLngLat([lng, lat])
                                    .setPopup(new mapboxgl.Popup({ offset: 15 })
                                        .setHTML(`
                                            <div style="padding: 8px;">
                                                <div style="font-weight: bold;">📍 Your Location</div>
                                                <div style="font-size: 11px; color: #666; margin-top: 4px;">
                                                    Accuracy: ±${Math.round(accuracy)}m
                                                </div>
                                            </div>
                                        `))
                                    .addTo(this.map);
                            }
                            
                            // Trigger the Mapbox geolocate control too
                            if (this.geolocateControl) {
                                this.geolocateControl.trigger();
                            }
                        },
                        (error) => {
                            console.error('GPS Error:', error);
                            let errorMsg = 'Unable to get your location. ';
                            
                            switch(error.code) {
                                case error.PERMISSION_DENIED:
                                    errorMsg += 'Please allow location access in your browser.';
                                    break;
                                case error.POSITION_UNAVAILABLE:
                                    errorMsg += 'Location information unavailable.';
                                    break;
                                case error.TIMEOUT:
                                    errorMsg += 'Location request timed out.';
                                    break;
                                default:
                                    errorMsg += error.message;
                            }
                            
                            alert(errorMsg);
                        },
                        {
                            enableHighAccuracy: true,
                            timeout: 10000,
                            maximumAge: 0
                        }
                    );
                },
                
                showHomeView() {
                    console.log('🏠 Showing Home View - All properties overview');
                    
                    if (!this.map) {
                        alert('Map not ready yet. Please wait a moment and try again.');
                        return;
                    }
                    
                    if (this.properties.length === 0) {
                        alert('No properties loaded yet. Please upload a CSV first.');
                        return;
                    }
                    
                    // Clear any filters to show ALL properties
                    this.propertyFilter = 'all';
                    this.equityFilter = 'all';
                    this.absenteeFilter = 'all';
                    this.tagFilter = 'all';
                    this.filterProperties();
                    
                    // Show ALL properties on map (not paginated)
                    this.showAllMarkersOnMap();
                    
                    // Fit map to show all properties
                    const bounds = new mapboxgl.LngLatBounds();
                    this.properties.forEach(prop => {
                        if (prop.lat && prop.lng) {
                            bounds.extend([prop.lng, prop.lat]);
                        }
                    });
                    
                    if (!bounds.isEmpty()) {
                        this.map.fitBounds(bounds, { 
                            padding: 50,
                            pitch: 45,  // Tilt for 3D view
                            bearing: -17.6,  // Slight rotation
                            duration: 2000
                        });
                    }
                    
                    // Show summary
                    const summary = {
                        total: this.properties.length,
                        absentee: this.properties.filter(p => p.absentee).length,
                        highEquity: this.properties.filter(p => p.equity > 50).length,
                        owner: this.properties.filter(p => !p.absentee).length
                    };
                    
                    console.log(`📊 Home View Summary:
                        Total Properties: ${summary.total}
                        🟠 Absentee: ${summary.absentee}
                        🔴 High Equity (>50%): ${summary.highEquity}
                        🔵 Owner Occupied: ${summary.owner}`);
                },
                
                showAllMarkersOnMap() {
                    // Remove existing markers
                    this.markers.forEach(m => m.remove());
                    this.markers = [];
                    
                    console.log(`🗺️ Adding ALL ${this.properties.length} properties to map with color coding`);
                    
                    // Add color-coded markers for ALL properties
                    this.properties.forEach(prop => {
                        if (prop.lat && prop.lng) {
                            // Determine marker color and size based on property characteristics
                            let markerColor = '#3b82f6';  // Default blue for owner-occupied
                            let markerSize = 'small';
                            
                            if (prop.absentee && prop.equity > 70) {
                                markerColor = '#ff0000';  // Red for HOT (absentee + high equity)
                                markerSize = 'large';
                            } else if (prop.absentee) {
                                markerColor = '#ff6b00';  // Orange for absentee
                                markerSize = 'medium';
                            } else if (prop.equity > 50) {
                                markerColor = '#fbbf24';  // Yellow for high equity
                                markerSize = 'medium';
                            } else if (prop.tags && prop.tags.includes('contacted')) {
                                markerColor = '#10b981';  // Green for contacted
                                markerSize = 'small';
                            }
                            
                            // Create custom marker element
                            const el = document.createElement('div');
                            el.style.width = markerSize === 'large' ? '20px' : markerSize === 'medium' ? '16px' : '12px';
                            el.style.height = markerSize === 'large' ? '20px' : markerSize === 'medium' ? '16px' : '12px';
                            el.style.backgroundColor = markerColor;
                            el.style.border = '2px solid white';
                            el.style.borderRadius = '50%';
                            el.style.cursor = 'pointer';
                            el.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
                            
                            const marker = new mapboxgl.Marker(el)
                                .setLngLat([prop.lng, prop.lat])
                                .setPopup(new mapboxgl.Popup({ offset: 15 })
                                    .setHTML(`
                                        <div style="padding: 8px; min-width: 200px;">
                                            <div style="font-weight: bold; margin-bottom: 4px;">${prop.address}</div>
                                            <div style="color: #666; font-size: 12px;">Owner: ${prop.owner}</div>
                                            <div style="margin-top: 8px;">
                                                <span style="background: ${prop.absentee ? '#ff6b00' : '#10b981'}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px;">
                                                    ${prop.absentee ? 'Absentee' : 'Owner'}
                                                </span>
                                                <span style="background: ${prop.equity > 50 ? '#dc2626' : '#3b82f6'}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">
                                                    ${prop.equity}% Equity
                                                </span>
                                            </div>
                                            ${prop.phone ? `<div style="margin-top: 8px; font-size: 12px;">📞 ${prop.phone}</div>` : ''}
                                        </div>
                                    `))
                                .addTo(this.map);
                            
                            // Add click handler to select property
                            el.addEventListener('click', () => {
                                this.showPropertyDetails(prop);
                            });
                            
                            this.markers.push(marker);
                        }
                    });
                    
                    // Add legend to map
                    this.addMapLegend();
                },
                
                addMapLegend() {
                    // Remove existing legend if any
                    const existingLegend = document.getElementById('map-legend');
                    if (existingLegend) {
                        existingLegend.remove();
                    }
                    
                    // Create legend
                    const legend = document.createElement('div');
                    legend.id = 'map-legend';
                    legend.style.cssText = `
                        position: absolute;
                        bottom: 30px;
                        left: 10px;
                        background: rgba(0, 0, 0, 0.8);
                        color: white;
                        padding: 10px;
                        border-radius: 8px;
                        font-size: 11px;
                        z-index: 100;
                    `;
                    legend.innerHTML = `
                        <div style="font-weight: bold; margin-bottom: 5px;">Property Status</div>
                        <div style="margin: 3px 0;"><span style="display: inline-block; width: 12px; height: 12px; background: #ff0000; border-radius: 50%; margin-right: 5px;"></span> Hot (Absentee + High Equity)</div>
                        <div style="margin: 3px 0;"><span style="display: inline-block; width: 12px; height: 12px; background: #ff6b00; border-radius: 50%; margin-right: 5px;"></span> Absentee Owner</div>
                        <div style="margin: 3px 0;"><span style="display: inline-block; width: 12px; height: 12px; background: #fbbf24; border-radius: 50%; margin-right: 5px;"></span> High Equity (>50%)</div>
                        <div style="margin: 3px 0;"><span style="display: inline-block; width: 12px; height: 12px; background: #10b981; border-radius: 50%; margin-right: 5px;"></span> Contacted</div>
                        <div style="margin: 3px 0;"><span style="display: inline-block; width: 12px; height: 12px; background: #3b82f6; border-radius: 50%; margin-right: 5px;"></span> Owner Occupied</div>
                    `;
                    
                    document.getElementById('map').appendChild(legend);
                },
                
                showFarmOverview() {
                    console.log('showFarmOverview button clicked!');
                    console.log('🗺️ Showing farm aerial overview...');
                    
                    if (!this.map) {
                        alert('Map not ready yet. Please wait a moment and try again.');
                        return;
                    }
                    
                    if (this.properties.length === 0) {
                        alert('No farm data loaded yet. Please upload a CSV first.');
                        return;
                    }
                    
                    // Ensure all properties have coordinates
                    let coordsGenerated = 0;
                    this.properties.forEach((prop, index) => {
                        if (!prop.lat || !prop.lng || isNaN(prop.lat) || isNaN(prop.lng)) {
                            const row = Math.floor(index / 70);
                            const col = index % 70;
                            prop.lat = 37.6288 + (row * 0.002);
                            prop.lng = -122.1208 + (col * 0.002);
                            coordsGenerated++;
                        }
                    });
                    
                    if (coordsGenerated > 0) {
                        console.log(`Generated coordinates for ${coordsGenerated} properties`);
                    }
                    
                    // Clear and refresh markers
                    this.markers.forEach(m => m.remove());
                    this.markers = [];
                    
                    // Add markers with custom HTML elements (Mapbox method)
                    this.addCustomMarkers();
                    
                    // Refresh pagination markers too
                    setTimeout(() => {
                        this.updatePagination();
                        this.addMapMarkers();
                    }, 500);
                    
                    // Calculate bounds for all properties
                    let minLat = 90, maxLat = -90, minLng = 180, maxLng = -180;
                    let validProps = 0;
                    
                    this.properties.forEach(prop => {
                        if (prop.lat && prop.lng && !isNaN(prop.lat) && !isNaN(prop.lng)) {
                            minLat = Math.min(minLat, prop.lat);
                            maxLat = Math.max(maxLat, prop.lat);
                            minLng = Math.min(minLng, prop.lng);
                            maxLng = Math.max(maxLng, prop.lng);
                            validProps++;
                        }
                    });
                    
                    if (validProps > 0) {
                        const centerLat = (minLat + maxLat) / 2;
                        const centerLng = (minLng + maxLng) / 2;
                        
                        console.log(`✈️ Flying to ${validProps} properties:`, {
                            center: [centerLng, centerLat],
                            bounds: { minLat, maxLat, minLng, maxLng }
                        });
                        
                        // First set center and zoom
                        this.map.setCenter([centerLng, centerLat]);
                        this.map.setZoom(12);
                        
                        // Then animate to aerial view
                        setTimeout(() => {
                            this.map.easeTo({
                                pitch: 50,
                                bearing: -20,
                                duration: 1500
                            });
                        }, 500);
                        
                        // Show toast notification
                        const notification = document.createElement('div');
                        notification.innerHTML = `
                            <div style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #8b5cf6; color: white; padding: 12px 24px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 9999;">
                                ✈️ Showing aerial view of ${validProps} properties
                            </div>
                        `;
                        document.body.appendChild(notification);
                        setTimeout(() => notification.remove(), 2000);
                    } else {
                        console.error('No valid coordinates found');
                        alert('Unable to show aerial view - no valid property coordinates');
                    }
                },
                
                // Add 3D Building Layer
                // Add custom markers using HTML elements (Mapbox)
                addCustomMarkers() {
                    console.log('Adding custom HTML markers...');
                    
                    if (!this.map) return;
                    
                    // Limit to 50 markers for visibility
                    const propsToShow = this.properties.slice(0, 50);
                    
                    propsToShow.forEach((prop, index) => {
                        if (prop.lat && prop.lng && !isNaN(prop.lat) && !isNaN(prop.lng)) {
                            try {
                                // Create custom HTML element for marker
                                const el = document.createElement('div');
                                el.id = `marker-${prop.id}`;
                                el.style.width = '24px';
                                el.style.height = '24px';
                                el.style.borderRadius = '50%';
                                el.style.border = '3px solid white';
                                el.style.boxShadow = '0 2px 6px rgba(0,0,0,0.4)';
                                el.style.cursor = 'pointer';
                                el.style.backgroundColor = prop.absentee ? '#ff6b00' : '#00d084';
                                
                                // Add to map
                                const marker = new mapboxgl.Marker({ 
                                    element: el,
                                    anchor: 'center'
                                })
                                .setLngLat([prop.lng, prop.lat])
                                .addTo(this.map);
                                
                                // Add click handler
                                el.addEventListener('click', () => {
                                    this.selectedProperty = prop;
                                    this.flyToProperty(prop);
                                });
                                
                                this.markers.push(marker);
                            } catch (err) {
                                console.error('Error adding custom marker:', err);
                            }
                        }
                    });
                    
                    console.log(`Added ${this.markers.length} custom markers`);
                },
                
                add3DBuildingLayer() {
                    // Mapbox GL JS handles 3D buildings natively
                    // Buildings are part of the base style when pitch is enabled
                    // Just ensure we have the right style and pitch
                    
                    console.log('Enabling 3D view with pitch...');
                    
                    // Set optimal 3D viewing parameters
                    if (this.is3D) {
                        this.map.easeTo({
                            pitch: 60,
                            bearing: -17.6,
                            duration: 1000
                        });
                        
                        // Check if we're using a style that supports 3D buildings
                        const currentStyle = this.map.getStyle();
                        if (currentStyle) {
                            // Look for building layers in the current style
                            const layers = currentStyle.layers || [];
                            const hasBuildingLayers = layers.some(layer => 
                                layer.id && layer.id.includes('building')
                            );
                            
                            if (hasBuildingLayers) {
                                console.log('✅ 3D buildings are available in current style');
                                
                                // Enhance existing building layers if they're fill type
                                layers.forEach(layer => {
                                    if (layer.id && layer.id.includes('building') && layer.type === 'fill') {
                                        // Try to convert to fill-extrusion if possible
                                        try {
                                            // Check if this is a building layer we can enhance
                                            const paint = layer.paint || {};
                                            if (!paint['fill-extrusion-height']) {
                                                // Add extrusion properties to existing building layer
                                                this.map.setPaintProperty(layer.id, 'fill-opacity', 0.8);
                                            }
                                        } catch (e) {
                                            console.log('Layer enhancement not needed for:', layer.id);
                                        }
                                    }
                                });
                            } else {
                                console.log('⚠️ No building layers found in current style');
                                console.log('Buildings will appear when zoomed in sufficiently');
                            }
                        }
                    }
                    
                    console.log('✅ 3D view enabled - buildings will render based on style and zoom level');
                },
                
                // Traffic Flow Layer
                addTrafficFlow() {
                    // Add traffic flow layer
                    if (this.showTraffic && !this.map.getLayer('traffic-flow')) {
                        this.map.addLayer({
                            'id': 'traffic-flow',
                            'type': 'line',
                            'source': {
                                'type': 'vector',
                                'url': 'mapbox://mapbox.mapbox-traffic-v1'
                            },
                            'source-layer': 'flow',
                            'paint': {
                                'line-color': [
                                    'match',
                                    ['get', 'traffic_level'],
                                    0, '#00ff00',  // Free flow - green
                                    1, '#ffff00',  // Slow - yellow  
                                    2, '#ff9900',  // Queuing - orange
                                    3, '#ff0000',  // Stationary - red
                                    '#00ff00'
                                ],
                                'line-width': 3,
                                'line-opacity': 0.7
                            }
                        });
                    }
                },
                
                // Drive Time Polygon (Isochrone) - Great for farming!
                async showDriveTimeArea(minutes = 10) {
                    const center = this.map.getCenter();
                    
                    try {
                        const response = await fetch(
                            // Mapbox API for isochrone calculation
                            `key=${this.API_KEY}&timeBudgetInSec=${minutes * 60}&departAt=now`
                        );
                        
                        const data = await response.json();
                        
                        if (data.reachableRange) {
                            // Add polygon showing driveable area
                            const coordinates = data.reachableRange.boundary.map(point => [point.lng, point.lat]);
                            
                            if (this.map.getSource('drive-time')) {
                                this.map.removeLayer('drive-time-fill');
                                this.map.removeLayer('drive-time-line');
                                this.map.removeSource('drive-time');
                            }
                            
                            this.map.addSource('drive-time', {
                                'type': 'geojson',
                                'data': {
                                    'type': 'Feature',
                                    'geometry': {
                                        'type': 'Polygon',
                                        'coordinates': [coordinates]
                                    }
                                }
                            });
                            
                            this.map.addLayer({
                                'id': 'drive-time-fill',
                                'type': 'fill',
                                'source': 'drive-time',
                                'paint': {
                                    'fill-color': '#ff9500',
                                    'fill-opacity': 0.2
                                }
                            });
                            
                            this.map.addLayer({
                                'id': 'drive-time-line',
                                'type': 'line',
                                'source': 'drive-time',
                                'paint': {
                                    'line-color': '#ff9500',
                                    'line-width': 2
                                }
                            });
                            
                            // Filter properties within drive time
                            this.filterPropertiesInDriveTime(coordinates);
                        }
                    } catch (error) {
                        console.error('Drive time error:', error);
                    }
                },
                
                // Filter properties within drive time polygon
                filterPropertiesInDriveTime(polygon) {
                    // Simple point-in-polygon check
                    this.filteredProperties = this.properties.filter(prop => {
                        if (!prop.lat || !prop.lng) return false;
                        
                        // Basic point-in-polygon algorithm
                        let inside = false;
                        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                            const xi = polygon[i][0], yi = polygon[i][1];
                            const xj = polygon[j][0], yj = polygon[j][1];
                            
                            const intersect = ((yi > prop.lat) !== (yj > prop.lat))
                                && (prop.lng < (xj - xi) * (prop.lat - yi) / (yj - yi) + xi);
                            if (intersect) inside = !inside;
                        }
                        return inside;
                    });
                    
                    this.addMapMarkers();
                    console.log(`Found ${this.filteredProperties.length} properties within ${minutes} minute drive`);
                },
                
                // Route optimization for property tours
                async optimizePropertyTour(propertyList) {
                    if (propertyList.length < 2) return;
                    
                    const locations = propertyList
                        .filter(p => p.lat && p.lng)
                        .map(p => `${p.lng},${p.lat}`)
                        .join(':');
                    
                    try {
                        const response = await fetch(
                            // Mapbox Directions API
                            `key=${this.API_KEY}&routeType=fastest&traffic=true&travelMode=car&computeBestOrder=true`
                        );
                        
                        const data = await response.json();
                        
                        if (data.routes && data.routes[0]) {
                            const route = data.routes[0];
                            
                            // Draw optimized route on map
                            const coordinates = route.legs.flatMap(leg => 
                                leg.points.map(point => [point.longitude, point.latitude])
                            );
                            
                            if (this.map.getSource('tour-route')) {
                                this.map.removeLayer('tour-route');
                                this.map.removeSource('tour-route');
                            }
                            
                            this.map.addSource('tour-route', {
                                'type': 'geojson',
                                'data': {
                                    'type': 'Feature',
                                    'geometry': {
                                        'type': 'LineString',
                                        'coordinates': coordinates
                                    }
                                }
                            });
                            
                            this.map.addLayer({
                                'id': 'tour-route',
                                'type': 'line',
                                'source': 'tour-route',
                                'paint': {
                                    'line-color': '#00ff41',
                                    'line-width': 4,
                                    'line-opacity': 0.8
                                }
                            });
                            
                            // Show tour stats
                            const totalTime = Math.round(route.summary.travelTimeInSeconds / 60);
                            const totalDistance = (route.summary.lengthInMeters / 1609.34).toFixed(1);
                            
                            alert(`Optimized Tour:\n⏱️ Time: ${totalTime} minutes\n📍 Distance: ${totalDistance} miles\n🏠 Properties: ${propertyList.length}`);
                        }
                    } catch (error) {
                        console.error('Route optimization error:', error);
                    }
                },
                
                // Helper functions for property details panel
                getPropertyNote(property) {
                    if (!property) return '';
                    return this.propertyNotes[property.id] || '';
                },
                
                savePropertyNote(property, note) {
                    if (!property) return;
                    // Update both the reactive state and localStorage
                    this.propertyNotes[property.id] = note;
                    localStorage.setItem('property_notes', JSON.stringify(this.propertyNotes));
                },
                
                addPropertyNote() {
                    if (!this.selectedProperty || !this.newPropertyNote.trim()) return;
                    
                    // Initialize notes array if it doesn't exist
                    if (!this.selectedProperty.notes) {
                        this.selectedProperty.notes = [];
                    }
                    
                    // Add new note with timestamp
                    const newNote = {
                        id: Date.now(),
                        content: this.newPropertyNote,
                        timestamp: new Date().toLocaleString('en-US', { 
                            month: 'short', 
                            day: 'numeric', 
                            hour: '2-digit', 
                            minute: '2-digit' 
                        }),
                        isVoice: false
                    };
                    
                    this.selectedProperty.notes.unshift(newNote);
                    this.newPropertyNote = ''; // Clear input
                    this.saveToLocalStorage();
                },
                
                deleteNote(noteId) {
                    if (!this.selectedProperty || !this.selectedProperty.notes) return;
                    
                    if (confirm('Delete this note?')) {
                        this.selectedProperty.notes = this.selectedProperty.notes.filter(n => n.id !== noteId);
                        this.saveToLocalStorage();
                    }
                },
                
                editNote(note) {
                    if (!note) return;
                    
                    const newContent = prompt('Edit note:', note.content);
                    if (newContent && newContent.trim()) {
                        note.content = newContent.trim();
                        note.timestamp = new Date().toLocaleString('en-US', { 
                            month: 'short', 
                            day: 'numeric', 
                            hour: '2-digit', 
                            minute: '2-digit' 
                        }) + ' (edited)';
                        this.saveToLocalStorage();
                    }
                },
                
                async startVoiceRecording() {
                    // Show voice recording modal
                    this.showVoiceModal();
                },
                
                showVoiceModal() {
                    // Create modal overlay
                    const modal = document.createElement('div');
                    modal.id = 'voice-modal';
                    modal.style.cssText = `
                        position: fixed;
                        inset: 0;
                        background: rgba(0, 0, 0, 0.8);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 9999;
                    `;
                    
                    modal.innerHTML = `
                        <div style="background: #1a1a2e; border-radius: 16px; padding: 32px; max-width: 400px; width: 90%; text-align: center;">
                            <h3 style="color: white; margin-bottom: 16px; font-size: 20px;">Voice Note</h3>
                            <p style="color: #94a3b8; margin-bottom: 24px; font-size: 14px;">
                                ${this.selectedProperty?.address || '123 Main St, Hayward, CA'}
                            </p>
                            
                            <div id="mic-icon" style="margin: 24px auto; width: 80px; height: 80px; background: #dc2626; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s;">
                                <span style="font-size: 36px;">🎤</span>
                            </div>
                            
                            <div id="voice-status" style="color: #94a3b8; margin: 16px 0; font-size: 14px;">
                                Starting recording...
                            </div>
                            
                            <textarea id="voice-transcript" 
                                     style="width: 100%; height: 100px; background: #0f172a; border: 1px solid #374151; border-radius: 8px; color: white; padding: 12px; margin: 16px 0; display: none; font-size: 14px;"
                                     placeholder="Your transcribed text will appear here..."></textarea>
                            
                            <div style="display: flex; gap: 12px; margin-top: 24px;">
                                <button id="stop-btn" 
                                        style="flex: 1; background: #dc2626; color: white; padding: 12px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; display: none;">
                                    Stop Recording
                                </button>
                                <button id="save-btn"
                                        style="flex: 1; background: #3b82f6; color: white; padding: 12px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; display: none;">
                                    Add Note
                                </button>
                                <button id="cancel-btn"
                                        style="flex: 1; background: #374151; color: white; padding: 12px; border: none; border-radius: 8px; cursor: pointer;">
                                    Cancel
                                </button>
                            </div>
                        </div>
                    `;
                    
                    document.body.appendChild(modal);
                    
                    // Setup event listeners
                    const micIcon = modal.querySelector('#mic-icon');
                    const stopBtn = modal.querySelector('#stop-btn');
                    const saveBtn = modal.querySelector('#save-btn');
                    const cancelBtn = modal.querySelector('#cancel-btn');
                    const status = modal.querySelector('#voice-status');
                    const transcript = modal.querySelector('#voice-transcript');
                    
                    let mediaRecorder = null;
                    let audioChunks = [];
                    
                    // Auto-start recording when modal opens
                    const startRecording = async () => {
                        try {
                            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                            mediaRecorder = new MediaRecorder(stream);
                            audioChunks = [];
                            
                            // Set up Web Speech API for transcription
                            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                            if (SpeechRecognition) {
                                const recognition = new SpeechRecognition();
                                recognition.continuous = true;
                                recognition.interimResults = true;
                                recognition.lang = 'en-US';
                                
                                let finalTranscript = '';
                                
                                recognition.onresult = (event) => {
                                    let interimTranscript = '';
                                    
                                    for (let i = event.resultIndex; i < event.results.length; i++) {
                                        const result = event.results[i];
                                        if (result.isFinal) {
                                            finalTranscript += result[0].transcript + ' ';
                                        } else {
                                            interimTranscript += result[0].transcript;
                                        }
                                    }
                                    
                                    // Show live transcription
                                    transcript.style.display = 'block';
                                    transcript.value = finalTranscript + interimTranscript;
                                };
                                
                                recognition.onerror = (event) => {
                                    console.error('Speech recognition error:', event.error);
                                    if (event.error === 'no-speech') {
                                        transcript.value = '(No speech detected)';
                                    }
                                };
                                
                                recognition.onend = () => {
                                    console.log('Speech recognition ended');
                                };
                                
                                // Start speech recognition
                                recognition.start();
                                
                                // Store recognition instance to stop it later
                                modal.recognition = recognition;
                            }
                            
                            mediaRecorder.ondataavailable = event => {
                                audioChunks.push(event.data);
                            };
                            
                            mediaRecorder.onstop = () => {
                                const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                                // Stop speech recognition
                                if (modal.recognition) {
                                    modal.recognition.stop();
                                }
                                // Recording stopped, transcript should already be populated by speech recognition
                                if (!transcript.value || transcript.value.trim() === '') {
                                    transcript.value = '(No speech detected - please try again)';
                                }
                                saveBtn.style.display = 'block';
                                status.textContent = 'Recording complete - review and save';
                            };
                            
                            mediaRecorder.start();
                            micIcon.style.background = '#ef4444';
                            micIcon.style.animation = 'pulse 1.5s infinite';
                            status.textContent = 'Recording... Speak now';
                            stopBtn.style.display = 'block';
                            cancelBtn.textContent = 'Cancel';
                        } catch (err) {
                            console.error('Error accessing microphone:', err);
                            status.textContent = 'Please allow microphone access';
                            alert('Please allow microphone access to record voice notes');
                        }
                    };
                    
                    // Start recording immediately when modal opens
                    startRecording();
                    
                    // If mic is clicked and we're already recording, stop it
                    micIcon.addEventListener('click', async () => {
                        if (mediaRecorder && mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                            mediaRecorder.stream.getTracks().forEach(track => track.stop());
                            micIcon.style.animation = 'none';
                            stopBtn.style.display = 'none';
                        } else if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                            // If not recording, start again
                            startRecording();
                        }
                    });
                    
                    // Stop recording
                    stopBtn.addEventListener('click', () => {
                        if (mediaRecorder && mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                            mediaRecorder.stream.getTracks().forEach(track => track.stop());
                            micIcon.style.animation = 'none';
                            stopBtn.style.display = 'none';
                        }
                    });
                    
                    // Save transcribed note
                    saveBtn.addEventListener('click', () => {
                        const noteContent = transcript.value.trim();
                        if (noteContent) {
                            this.addVoiceNote(noteContent);
                        }
                        modal.remove();
                    });
                    
                    // Cancel
                    cancelBtn.addEventListener('click', () => {
                        if (mediaRecorder && mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                            mediaRecorder.stream.getTracks().forEach(track => track.stop());
                        }
                        modal.remove();
                    });
                    
                    // Add pulse animation
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes pulse {
                            0% { transform: scale(1); opacity: 1; }
                            50% { transform: scale(1.05); opacity: 0.8; }
                            100% { transform: scale(1); opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                },
                
                addVoiceNote(content) {
                    if (!this.selectedProperty || !content) return;
                    
                    // Initialize notes array if it doesn't exist
                    if (!this.selectedProperty.notes) {
                        this.selectedProperty.notes = [];
                    }
                    
                    // Add new voice note with timestamp
                    const newNote = {
                        id: Date.now(),
                        content: content,
                        timestamp: new Date().toLocaleString('en-US', { 
                            month: 'short', 
                            day: 'numeric', 
                            hour: '2-digit', 
                            minute: '2-digit' 
                        }),
                        isVoice: true
                    };
                    
                    this.selectedProperty.notes.unshift(newNote);
                    this.saveToLocalStorage();
                },
                
                isInHotList(property) {
                    if (!property) return false;
                    return this.hotList.some(p => p.id === property.id);
                },
                
                toggleHotList(property) {
                    if (!property) return;
                    const index = this.hotList.findIndex(p => p.id === property.id);
                    if (index > -1) {
                        this.hotList.splice(index, 1);
                    } else {
                        this.hotList.push(property);
                    }
                    // Save to localStorage
                    localStorage.setItem('hot_list', JSON.stringify(this.hotList.map(p => p.id)));
                },
                
                callOwner(property) {
                    if (!property || !property.phone) {
                        alert('No phone number available for this property');
                        return;
                    }
                    window.location.href = `tel:${property.phone}`;
                },
                
                routeToProperty(property) {
                    if (!property || !property.lat || !property.lng) {
                        alert('No location data available for this property');
                        return;
                    }
                    // Open in Apple Maps on iOS or Google Maps on other platforms
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                    const mapsUrl = isIOS 
                        ? `maps://maps.apple.com/?daddr=${property.lat},${property.lng}&dirflg=d`
                        : `https://www.google.com/maps/dir/?api=1&destination=${property.lat},${property.lng}`;
                    window.open(mapsUrl, '_blank');
                },
                
                showPropertyNotes(property) {
                    if (!property) return;
                    const currentNote = this.getPropertyNote(property);
                    const newNote = prompt(`Notes for ${property.address}:`, currentNote || '');
                    if (newNote !== null) {
                        this.savePropertyNote(property, newNote);
                    }
                },
                
                exportProperty(property) {
                    if (!property) return;
                    const data = `Property: ${property.address}
Owner: ${property.owner}
Phone: ${property.phone || 'N/A'}
Equity: ${property.equity}%
Type: ${property.type || 'Unknown'}
Status: ${property.absentee ? 'Absentee' : 'Owner Occupied'}
Notes: ${this.getPropertyNote(property) || 'None'}`;
                    
                    const blob = new Blob([data], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${property.address.replace(/[^a-z0-9]/gi, '_')}.txt`;
                    a.click();
                }
            };
        }
    </script>
</body>
</html>